<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CSharp1 - EESAST Training 2020</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../git/git.html"><strong aria-hidden="true">2.</strong> Git</a></li><li class="chapter-item expanded "><a href="../web/web.html"><strong aria-hidden="true">3.</strong> Web</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../web/html&css.html"><strong aria-hidden="true">3.1.</strong> HTML&amp;CSS</a></li><li class="chapter-item expanded "><a href="../web/js&ts.html"><strong aria-hidden="true">3.2.</strong> JS&amp;TS</a></li><li class="chapter-item expanded "><a href="../web/react.html"><strong aria-hidden="true">3.3.</strong> React + antd 入门</a></li></ol></li><li class="chapter-item expanded "><a href="../linux-webserver/linux.html"><strong aria-hidden="true">4.</strong> Linux</a></li><li class="chapter-item expanded "><a href="../docker/docker.html"><strong aria-hidden="true">5.</strong> Docker</a></li><li class="chapter-item expanded "><a href="../OS/OS.html"><strong aria-hidden="true">6.</strong> 操作系统</a></li><li class="chapter-item expanded "><a href="../CSharp/CS-Learning1-Basic.html" class="active"><strong aria-hidden="true">7.</strong> CSharp1</a></li><li class="chapter-item expanded "><a href="../CSharp/CS-Learning2-MultiThread.html"><strong aria-hidden="true">8.</strong> CSharp2</a></li><li class="chapter-item expanded "><a href="../unity/unity.html"><strong aria-hidden="true">9.</strong> Unity</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">EESAST Training 2020</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/eesast/training2020" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h4><a class="header" href="#c概述" id="c概述">C#：概述</a></h4>
<p>C# 语法高度重视表达，但学习起来也很简单轻松。 任何熟悉 C、C++ 或 Java 的人都可以立即认出 C# 的大括号语法。 通常情况下，了解上述任何一种语言的开发者都可在短时间内就开始使用 C# 高效工作。 C# 语法简化了 C++ 的许多复杂操作，并提供强大功能，如可以为 null 的类型、枚举、委托、lambda 表达式和直接内存访问。 </p>
<p>作为面向对象的语言，C# 支持封装、继承和多态性这些概念。 所有变量和方法（包括作为应用程序入口点的 <code>Main</code> 方法）都封装在类定义中。 虽然类可能会直接继承一个父类，但可以实现任意数量的接口。 若要用方法重写父类中的虚方法，必须使用 <code>override</code> 关键字，以免发生意外重定义。 在 C# 中，结构就像是轻量级类，是可以实现接口但不支持继承的堆栈分配类型。</p>
<p>除了这些面向对象的基本原则，使用 C# 还可以通过以下多个创新语言构造更加轻松地开发软件组件：</p>
<ul>
<li>封装的方法签名（名为“<em>委托</em>”），可实现类型安全事件通知。</li>
<li>用作私有成员变量的访问器的属性。</li>
<li>在运行时提供有关类型的声明性元数据的特性。</li>
<li>内联的 XML 文档注释。</li>
<li>语言集成查询 (LINQ)，提供跨各种数据源的内置查询功能。</li>
</ul>
<p>C# 生成过程比 C 和 C++ 更简单，比 Java 更灵活。 没有单独的头文件，也不要求按特定顺序声明方法和类型。 C# 源文件可以定义任意数量的类、结构、接口和事件。</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/">微软官方文档</a></li>
</ul>
<h4><a class="header" href="#程序结构" id="程序结构">程序结构</a></h4>
<p>一个 C# 程序主要包括以下部分：</p>
<ul>
<li>命名空间声明（Namespace declaration）
<ul>
<li>Class 类声明
<ul>
<li>一个 Main 方法
<ul>
<li>语句（Statements）&amp; 表达式（Expressions）</li>
</ul>
</li>
<li>其他方法和属性</li>
</ul>
</li>
<li>其他类声明</li>
</ul>
</li>
<li>其他命名空间...</li>
</ul>
<pre><code class="language-c#">using System; // 在程序中包含System命名空间
namespace HelloWorldApplication // 声明命名空间
{
   class HelloWorld // 声明一个类
   {
      static void Main(string[] args) // 静态方法
      {
         /* 我的第一个 C# 程序*/
         HelloWorld n = new HelloWorld();
         Console.WriteLine(&quot;Hello World&quot;);  // System.Console.WriteLine
         /* 定义在 System 命名空间中的 Console 类的一个方法 */
         Console.ReadKey(); //等待一个按键的动作
      }
   }
}
</code></pre>
<h4><a class="header" href="#数据类型" id="数据类型">数据类型</a></h4>
<h5><a class="header" href="#值类型" id="值类型">值类型</a></h5>
<ul>
<li>bool，char，float(1.0F)，double(1.0D)，short(16)，int(32)，long(64)，uint...
<ul>
<li>byte 8位无符号整数</li>
<li>decimal：128位十进制整数/小数，有效位数28-29位(1.0M)</li>
<li>结构体(Struct)</li>
</ul>
</li>
<li>传参时进行值传递，拷贝副本</li>
<li>在栈空间上分配内存，不会给垃圾回收(GC)造成负担</li>
<li>不能派生其他子类，不能使用线程锁</li>
</ul>
<h5><a class="header" href="#引用类型" id="引用类型">引用类型</a></h5>
<ul>
<li>
<p>所有类型的基类object, 字符串string，数组Array，类class，接口interfac，委托delegate..</p>
</li>
<li>
<p>传参和直接赋值时进行引用传递，可以在函数内部改变其值</p>
<ul>
<li>
<p>string类较为特殊，string间赋值被重载为深复制</p>
<pre><code class="language-c#">string s1 = &quot;Hello, World!&quot;;
string s2 = s1;
s2 = &quot;See you!&quot;;
Console.WriteLine(s1); // &quot;Hello, World!&quot;
Console.WriteLine(s2); // &quot;See you!&quot;
</code></pre>
</li>
</ul>
</li>
<li>
<p>在堆空间上分配内存，并由GC机制进行内存管理</p>
</li>
<li>
<p>可以派生，可以使用线程锁等</p>
</li>
</ul>
<h5><a class="header" href="#指针类型" id="指针类型">指针类型</a></h5>
<ul>
<li>可以对方法添加unsafe关键字，并使用C，C++中的指针 int*等</li>
<li>在vs项目中设置允许使用不安全的代码</li>
<li>由于C#中的GC机制，一个变量（例如一个大数组）有可能在运行过程中被移动到内存中的其他位置，因此不建议使用指针类型(可以使用fixed关键字固定内存位置)</li>
<li>可以在unsafe环境中使用stackalloc分配栈内存，栈内存不受GC的影响</li>
</ul>
<h5><a class="header" href="#可空类型" id="可空类型">可空类型</a></h5>
<ul>
<li>定义变量时，在类型后添加?表示该变量可能为null：<code>double? num = null;</code></li>
<li>使用变量时，在变量后添加 ?? 表示若该变量为null，则使用 ?? 后的替换值
<ul>
<li><code>double num2 = num ?? 1.0</code></li>
</ul>
</li>
</ul>
<h5><a class="header" href="#类型转化" id="类型转化">类型转化</a></h5>
<ul>
<li>前加(类型名)，(int)</li>
<li>调用数据对象的ToString()，ToBoolean()，ToDouble()，Toint32()方法</li>
<li>调用System空间的Convert类的相应方法 <code>double a=Convert.ToDouble(1)</code></li>
<li>调用VarType.Parse()方法，参数必须为string，如 <code>Int.Parse(&quot;32&quot;)</code></li>
<li>使用as关键字，如果转换失败则返回null，只能用于引用类型间转化</li>
</ul>
<h5><a class="header" href="#类型判断" id="类型判断">类型判断</a></h5>
<ul>
<li>使用 is 关键字 <code>if( x is int)</code></li>
</ul>
<h5><a class="header" href="#装箱与拆箱" id="装箱与拆箱">装箱与拆箱</a></h5>
<ul>
<li>
<p>装箱：把值类型转换成引用类型；拆箱：把引用类型转换成值类型</p>
</li>
<li>
<pre><code class="language-c#">//装箱
int i = 1;
object obj = (object)i;
//拆箱
int j = (int)obj;
</code></pre>
</li>
<li>
<p>装箱与拆箱的过程会有性能损耗</p>
</li>
</ul>
<h4><a class="header" href="#基本语法" id="基本语法">基本语法</a></h4>
<h5><a class="header" href="#条件语句" id="条件语句">条件语句</a></h5>
<ul>
<li>if else：同C, C++</li>
<li>?运算符：同C, C++</li>
<li>switch case default：同C，C++，case需要添加break语句</li>
</ul>
<h5><a class="header" href="#循环语句" id="循环语句">循环语句</a></h5>
<ul>
<li>for( init; condition; end) 语句，同C, C++</li>
<li>while循环，do while循环，同C, C++</li>
<li>foreach语句
<ul>
<li>foreach(typename x in Array/Collection) //可迭代对象</li>
<li>逐一取出可迭代对象内的元素x，语句块内可以读取x的值，但不能改变x的值</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#string-字符串" id="string-字符串">String 字符串</a></h4>
<ul>
<li>String类的对象，用双引号表示字符串</li>
<li>使用String类的方法多种字符串操作
<ul>
<li>Compare, Concat, Contains, Copy, Ends/StartsWith, IndexOf, Insert, Replace, Remove, Split, Trim..</li>
</ul>
</li>
<li>使用ToCharList方法转换为字符数组</li>
<li>使用@前缀表示转义字符串：<code>@&quot;C:\Windows&quot;</code></li>
<li>使用$前缀进行字符串内插：</li>
</ul>
<pre><code class="language-c#">string name = &quot;Mark&quot;;
var date = DateTime.Now;
Console.WriteLine($&quot;Hello, {name}! Today is {date.DayOfWeek}.&quot;);
// Hello, Mark! Today is Wednesday.
</code></pre>
<ul>
<li>也可使用Format方法插入数值，但较为繁琐</li>
</ul>
<p><code>Console.WriteLine(&quot;Hello, {0}! Today is {1}.&quot;, name, date.DayOfWeek);</code></p>
<h4><a class="header" href="#array-数组" id="array-数组">Array 数组</a></h4>
<ul>
<li><code>double[] a = new double[10];</code> <code>double[] b = a;//a和b指向同一内存位置</code> </li>
<li><code>double[] a = { 2340.0, 4523.69, 3421.0};</code></li>
<li>数组作为参数传入时，函数体内可修改数组元素的值 </li>
</ul>
<h5><a class="header" href="#多维数组" id="多维数组">多维数组</a></h5>
<ul>
<li>
<p>类似矩阵的数据结构</p>
<pre><code class="language-c#">int [,] a = new int [2,3] 
{
 {0, 1, 2} ,
 {3, 4, 5} ,
};
</code></pre>
</li>
<li>
<p>访问元素：<code>int b = a[1,2] \\5</code></p>
</li>
<li>
<p>使用Rank属性获取多维数组的维数，使用GetLength(d)来获取第d维的长度</p>
</li>
<li>
<p>foreach循环会遍历每个元素</p>
</li>
</ul>
<h5><a class="header" href="#交错数组" id="交错数组">交错数组</a></h5>
<ul>
<li>类似C，C++中的多维数组，本质是“元素是数组的数组&quot;</li>
<li><code>int[][] a = new int[2][]{new int[]{92,93,94},new int[]{85,66,87,88}};</code></li>
<li>获取a的Rank属性，得到结果为1，foreach循环只会遍历各个数组</li>
</ul>
<h4><a class="header" href="#struct-结构体" id="struct-结构体">Struct 结构体</a></h4>
<ul>
<li>可以定义字段，属性(区别一会儿再说)，方法，构造函数，不能定义析构函数</li>
<li>可以声明静态成员</li>
<li>构造函数必须带参数，且在构造函数中必须为每个字段赋值</li>
<li>作为参数时是值传递，储存在栈空间中，所需空间较小</li>
<li>不能继承和派生</li>
</ul>
<pre><code class="language-c#">struct Books
{
   private string title;
   private string author;
   public Books(string t, string a)
   {
   		title = t;
        author = a;
   }
}; 
</code></pre>
<h4><a class="header" href="#enum-枚举" id="enum-枚举">Enum 枚举</a></h4>
<ul>
<li>同C, C++，默认为Public，可以显式指定枚举对应的值</li>
</ul>
<pre><code class="language-c#">enum Numbers
{
    One,
	Three = 3,
    Four // 从上一项的值+1
}
static void Main()
{
	Numbers num = Numbers.Three;
	Console.WriteLine(num); // &quot;Three&quot;
	int one = 1;
	num = (Numbers) one; // Enum和int可以强制类型转换
	Console.WriteLine(Convert.ToString(num)); // 使用Convert获取枚举字符串
	string four = &quot;Four&quot;;
	num = (Numbers)Enum.Parse(typeof(Numbers), four); //由字符串转换为枚举
	Console.WriteLine((int)num);
}
</code></pre>
<h4><a class="header" href="#class-类" id="class-类">Class 类</a></h4>
<ul>
<li>基本定义同C，C++，有构造和析构函数(不支持构造函数的简洁写法)</li>
<li>作为参数时是引用传递</li>
<li>静态变量和静态方法：该类的各个对象共享同一个变量，而<strong>静态方法只能使用静态变量，调用静态方法</strong>
<ul>
<li>main方法是静态方法，故Program类中的全局变量应该设为静态变量</li>
<li>可以使用类名.方法名，不实例化类的对象直接调用静态方法</li>
</ul>
</li>
</ul>
<h5><a class="header" href="#方法" id="方法">方法</a></h5>
<ul>
<li>在类中定义方法，每一个 C# 程序至少有一个带有 Main 方法的类。</li>
</ul>
<pre><code class="language-c#">   public int Max(int ref num1, int ref num2)
   {
       return num1 &gt; num2 ? num1 : num2;
   }
</code></pre>
<ul>
<li>
<p>使用非静态方法时必须先实例化类的对象，如在Program类中声明了main函数和以上Max函数，则在main函数中调用Max函数时，需先声明Program对象：<code>Program n = new Program();</code>，再调用相应的方法：<code>n.Max(ref a, ref b)</code></p>
</li>
<li>
<p>参数传递：</p>
<ul>
<li>值传递：拷贝值型变量的副本</li>
<li>引用参数：在方法的参数列表和调用方法时均增加<strong>ref</strong>关键字</li>
<li>输出参数：在方法的参数列表和调用方法时均增加<strong>out</strong>关键字, out参数必须在方法内赋值，且不能在赋值前被使用</li>
</ul>
</li>
</ul>
<h5><a class="header" href="#访问控制" id="访问控制">访问控制</a></h5>
<ul>
<li>public, private, protected(对该类对象及其子类对象可以访问)</li>
<li>如果不声明，则默认为private</li>
</ul>
<h5><a class="header" href="#继承与派生" id="继承与派生">继承与派生</a></h5>
<ul>
<li>继承和派生与C，C++类似，继承后子类可以访问父类中public和protected的字段，属性和方法</li>
</ul>
<table><thead><tr><th align="center"></th><th align="center">实方法</th><th align="center">虚方法</th><th align="center">抽象方法</th></tr></thead><tbody>
<tr><td align="center">修饰符</td><td align="center">/</td><td align="center">virtual</td><td align="center">abstract</td></tr>
<tr><td align="center">父类要求</td><td align="center">/</td><td align="center">/</td><td align="center">有抽象方法的类也为抽象类</td></tr>
<tr><td align="center">父类实现</td><td align="center">/</td><td align="center">父类必须给出虚方法的实现</td><td align="center">父类可以只声明抽象方法</td></tr>
<tr><td align="center">子类实现</td><td align="center">子类可以覆盖实方法</td><td align="center">子类可以重载或覆盖虚方法</td><td align="center">子类必须重载虚方法</td></tr>
<tr><td align="center">重载(override)</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr>
<tr><td align="center">覆盖(new)</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr>
<tr><td align="center">基类调用(base)</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr>
<tr><td align="center">密封类(sealed)</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr>
</tbody></table>
<ul>
<li>覆盖与重载的区别：覆盖后子类的实例可以调用父类被覆盖的方法(强制类型转换)，而重载后则不可以，对于虚方法一般使用重载</li>
<li>声明密封类：此类不能被继承</li>
</ul>
<pre><code class="language-c#">using System;

namespace CSharpLearning
{
    abstract class Animal // 有抽象方法的类必须是抽象类
    {
        public Animal(){};
        public void Move() // 实方法
        {
            Console.WriteLine(&quot;调用了Animal类的Move方法&quot;);
        }
        public virtual void Attack() // 虚方法，必须给出实现
        {
            Console.WriteLine(&quot;调用了Animal类的Attack方法&quot;);
        }
        public abstract void Name(); // 抽象方法，可以只声明，不实现

    }

    sealed class Cat : Animal // 密封类，不能派生，继承了Animal类
    {
        public override void Name() // 若不重载抽象方法则会报错
        {
            Console.WriteLine(&quot;调用了Cat类的Name方法&quot;);
        }

        public override void Attack() // 可以重载父类的虚方法，也可不重载，还可用new覆盖父类的虚方法
        {
            Console.WriteLine(&quot;调用了Cat类的Attack方法&quot;);
        }

        public new void Move() // 使用new覆盖父类的实方法
        {
            base.Move(); // 使用base关键字调用父类的同名方法
            Console.WriteLine(&quot;调用了Cat类的Move方法&quot;);
        }

    }
    class Program
    {
        static void Main(string[] args)
        {
            // Animal animal = new Animal(); 报错：无法创建抽象类Animal的实例
            Cat cat=new Cat();
            cat.Name(); // 调用了Cat类的Name方法
            cat.Move(); // 调用了Animal类的Move方法/n 调用了Cat类的Move方法
            ((Animal)cat).Move(); // 调用了Animal类的Move方法
            ((Animal)cat).Attack(); // 调用了Cat类的Attack方法
            Console.ReadKey();
        }
    }
}
</code></pre>
<h5><a class="header" href="#字段与属性" id="字段与属性">字段与属性</a></h5>
<ul>
<li><a href="https://www.cnblogs.com/doThing/p/properties-in-csharp.html">更多参考资料</a></li>
<li>字段又称“成员变量”，一般在类的内部做数据交互使用，命名时通常首字母小写</li>
<li>属性是外界访问私有字段的入口，负责指定相应字段的读、写方式，命名与对应字段相同且首字母大写</li>
<li>声明属性时，首先声明相应的私有字段，然后指定属性的get和set访问器</li>
</ul>
<pre><code class="language-c#">class Person
{
    private int age;
	public int Age
	{
		get { return age; }
    	set { age = value &gt; 120 ? 120 : value; }
        // 此处value为关键字，代表用户所赋的值
	}
}
</code></pre>
<ul>
<li>在C# 7.0之后也可用类似lambda表达式的方法设置属性</li>
</ul>
<pre><code class="language-c#">class Person
{
    private int age;
	public int Age { get =&gt; age; set =&gt; age = value &gt; 120 ? 120 : value; }
    // 注意set语句中仍需对age赋值
    // 如果只实现get访问器，则可以进一步简化为 public int Age =&gt; age;
}
</code></pre>
<ul>
<li>使用属性对应字段的值时，直接对属性读取或赋值：</li>
</ul>
<pre><code class="language-c#">Person person = new Person();
person.Age = 20;
Console.WriteLine(person.Age);
</code></pre>
<ul>
<li>
<p>若属性访问器中<strong>不需要任何其他逻辑</strong>时，我们可以使用自动实现的属性，不需要声明相应字段</p>
<p><code>public int Age { get; set; }</code></p>
</li>
<li>
<p>此时也可进行初始化<code>public string Name { get; set; } = &quot;Jane&quot;;</code></p>
</li>
<li>
<p>若去除set访问器，则属性变为只读的，必须为其指定初始值</p>
<p><code>public string Name { get; } = &quot;Jane&quot;;</code></p>
</li>
</ul>
<h4><a class="header" href="#运算符重载" id="运算符重载">运算符重载</a></h4>
<ul>
<li>基本与C，C++一致，使用operator关键字且应声明为static方法</li>
</ul>
<pre><code class="language-c#">public static Student operator +(Student s1, Student s2)
{
	return new Student(s1.age + s2.age, s1.name + &quot; And &quot; + s2.name);
}
</code></pre>
<ul>
<li>重载 == 操作符后也必须重载 != 操作符</li>
<li>重载 + 操作符后 += 操作符也自动被重载，- , * , / 等类似</li>
<li>使用Implict/Explict关键字重载隐式/显式类型转换运算符
<ul>
<li><code>public static implict operator A(B b)</code> 类型B到类型A的隐式转换</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#interface-接口" id="interface-接口">Interface 接口</a></h4>
<ul>
<li>接口使用 <strong>interface</strong> 关键字声明，它与类的声明类似。接口声明默认是 public 的</li>
<li>抽象类在某种程度上与接口类似，但是，抽象类大多用于只有少数方法由基类声明而由派生类实现时，接口则指定的其派生类应遵循的标准</li>
<li>接口通常以大写 I 开头命名，接口的定义与类的定义相似(interface关键字)，其中方法默认为public，接口内也可有属性的声明，但不能有字段</li>
<li>C#中不允许继承多个类，但可以继承多个接口</li>
<li>接口可以继承其他接口，而实现该接口的类应该实现所有接口的方法和属性</li>
</ul>
<pre><code class="language-c#">interface IPerson
{
　　string Name { get; set; }`
　　void Show(string name);
}

interface IStudent //也可继承IPerson接口，则Student类只需继承IStudent接口
{
　　string Id { get; set; }`
　　void Show(string id); //若继承IPerson接口，则应加new修饰符覆盖同名方法
}

class Student: IPerson, IStudent //多继承
{
　　public string Name { get; set; }`
　　public string Id { get; set; }`
      
　　void IPerson.Show(string name) //分别实现不同接口的同名方法
　　{
    　　Console.WriteLine(&quot;姓名为{0}&quot;, name);
　　}
    
　　void IStudent.Show(string id) //如果指定实现接口的函数，则可以不使用访问控制
　　{
    　　Console.WriteLine(&quot;学号为{0}&quot;, id);
　　}
    
	//public void Show(string id) //如果统一实现，则必须指定访问控制符
    	//{
        //    Console.WriteLine(&quot;姓名为{name},学号为{id}&quot;);
        //}
}

class Program
{
　　static void Main()
　　{
    　　Student s = new Student();
    　　Console.WriteLine(&quot;输入姓名&quot;);
    　　s.Name = Console.ReadLine();
    　　Console.WriteLine(&quot;输入学号&quot;);
    　　s.Id = Console.ReadLine();
    　　IPerson per = s;
    　　per.Show(s.Name);
    　　IStudent stu = s;
    　　stu.Show(s.Id);
　　}
}
</code></pre>
<ul>
<li>函数可以使用接口作为参数，在传参时传入不同实现该接口的类的实例</li>
</ul>
<h4><a class="header" href="#exception-异常处理" id="exception-异常处理">Exception 异常处理</a></h4>
<ul>
<li>类似C++的 try - throw - catch - finally结构</li>
<li>一个try块至少对应一个catch块或1个finally块</li>
<li>只会进入从上向下的第一个匹配的代码块，若当前函数中没有匹配的catch块则会搜索外层函数</li>
</ul>
<pre><code class="language-c#">static int GetInt(int[] array, int index)
{
	try
	{
		return array[index];
	}
	catch (System.IndexOutOfRangeException ex)  //下标越界的更具体原因在于传递了越界的参数index
	{
		Console.WriteLine(ex.Message);
        // 创建更精确的异常并抛出给外层函数
		throw new ArgumentException(&quot;index parameter is out of range.&quot;, &quot;index&quot;, ex);
    }
}
static void Main()
{
    try
    {
        int[] a = {1, 2, 3, 4, 5};
        GetInt(a, 5);
    }
    catch (ArgumentException ex)
    {
        Console.WriteLine(ex.Message);
    }
    catch (Exception)
    {
        Console.WriteLine(&quot;发生未知错误!&quot;);
    }
    finally //一般用于释放资源
    {
        Console.WriteLine(&quot;Done!&quot;);
    }
}
</code></pre>
<h4><a class="header" href="#delegate-委托" id="delegate-委托">Delegate 委托</a></h4>
<ul>
<li>类似于C, C++的函数指针，可用于引用任何返回值和参数列表相同的方法</li>
<li>delegate void printString(string s);`</li>
<li>声明委托后，使用new创建委托对象，并且传入要引用的函数名作为参数
<ul>
<li><code>printString ps1 = new printString(WriteToScreen);</code></li>
</ul>
</li>
<li>此后可以使用委托对象调用对应</li>
</ul>
<h5><a class="header" href="#多播委托" id="多播委托">多播委托</a></h5>
<ul>
<li>作用于参数和返回值相同的委托对象直接</li>
<li>委托类型重载了 + - 运算符，可用于依次执行一系列任务，再返回值</li>
</ul>
<pre><code class="language-c#">using System;
namespace Program
{
	delegate int NumberChanger(int n); // 委托可以直接在命名空间内声明
    class TestDelegate
    {
        public static int Num { get; set; } = 10;
        public static int AddNum(int p)
        {
            Num += p;
            return Num;
        }

        public static int MulNum(int q)
        {
            Num *= q;
            return Num;
        }
        static void Main(string[] args)
        {
            NumChanger fc1 = new NumChanger(AddNum);
            NumChanger fc2 = new NumChanger(MulNum);
            NumChanger fc = fc2 + fc1;
            Console.WriteLine(fc(5)); // 75 = (10 * 5) + 5
        }
    }
}
</code></pre>
<ul>
<li>委托可以接受匿名函数作为参数</li>
</ul>
<p><code>NumChanger fc1 = delegate(int p) { Num += p; return p;};</code></p>
<ul>
<li>也可以接受一个<strong>lambda表达式</strong>作为参数：</li>
</ul>
<p><code>NumChanger fc1 = (int p) =&gt;  { Num += p; return p;};</code> </p>
<h5><a class="header" href="#lambda表达式" id="lambda表达式">lambda表达式</a></h5>
<ul>
<li>表达式lambda，自动返回表达式的值
<ul>
<li>(int x, int y) =&gt; x * y 或省略类型声明 (x, y) =&gt; x * y</li>
<li>只有1个参数时可省略左侧的括号 x =&gt; x * x * x</li>
</ul>
</li>
<li>语句lambda
<ul>
<li>(int x, int y) =&gt; { return x * y; }</li>
<li>右侧用大括号扩起，内部可以有多条语句(不宜过多)，也可没有返回值</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#generic-泛型" id="generic-泛型">Generic 泛型</a></h4>
<ul>
<li>类似C++ 的模板，可以兼容不同的数据类型，但限制更多</li>
<li>泛型类：<code>class MyArray&lt;T&gt;</code></li>
<li>泛型方法： <code>static void Swap&lt;T&gt;(ref T x, ref T y)</code></li>
<li>泛型委托：<code>delegate T NumberChanger&lt;T&gt;(T n);</code></li>
<li>泛型接口：<code>interface IDictionary&lt;K, V&gt;</code></li>
<li>继承泛型类或接口时待定类型只能不变或增多</li>
</ul>
<h5><a class="header" href="#泛型的类型约束" id="泛型的类型约束">泛型的类型约束</a></h5>
<ul>
<li>
<p>声明泛型时可以给泛型添加一定的约束：<code>class MyArray&lt;T&gt; where T : struct</code></p>
</li>
<li>
<p>where T : struct ：T必须为(不可为空的)值类型</p>
</li>
<li>
<p>where T : class ：T必须为(不可为空的)引用类型</p>
</li>
<li>
<p>where T : notnull ：T必须为不可为空的类型</p>
</li>
<li>
<p>where T : new() ：T必须具有无参数的构造函数，不能与struct合用</p>
</li>
<li>
<p>where T : &lt;interface name&gt; ：T必须实现指定的接口</p>
</li>
<li>
<p>where T : &lt;base class name&gt; ：T必须为指定类或其派生类</p>
</li>
<li>
<p>多个限制并用：用逗号分隔</p>
</li>
<li>
<p>约束多个参数：</p>
<pre><code class="language-c#">class Base { }
class Test&lt;T, U&gt;
    where U : struct
    where T : Base, new()
</code></pre>
</li>
</ul>
<h4><a class="header" href="#collections-集合" id="collections-集合">Collections 集合</a></h4>
<ul>
<li>包含了一系列基本数据结构的命名空间</li>
<li>ArrayList, SortedList, Hashtable, Stack, Queue..
<ul>
<li>一般包含Add, Clear, Remove等方法</li>
</ul>
</li>
<li>包含一些基本的接口，如 IComparer, IEnumerator(迭代), IList(按索引访问)</li>
<li>并未指定成员的数据类型，因此全部成员都被转换为object类</li>
<li>对于值类型，使用Collections意味着频繁的装箱和拆箱，性能不佳</li>
</ul>
<h5><a class="header" href="#collectionsgeneric" id="collectionsgeneric">Collections.Generic</a></h5>
<ul>
<li>利用泛型值类数据类型的数据结构，拥有更好的类型安全性和性能</li>
<li>Tuple&lt;T1, T2, T3, ...&gt; ，使用.Item1, .Item2来访问，类似C++的pair
<ul>
<li>使用C# 7.0的新特性<strong>元组</strong>实现此功能</li>
<li>(1, 2)； (&quot;one&quot;, &quot;two&quot;)，...</li>
<li>可以为每个元组的元素起别名：（x : 1, y : 2)</li>
<li>元组支持直接赋值和比较</li>
</ul>
</li>
<li>List&lt;T&gt;  类似C++ vector</li>
<li>Dictionary&lt;T1, T2&gt;</li>
<li>Queue&lt;T&gt;， Stack&lt;T&gt;</li>
<li>HashSet&lt;T&gt;</li>
</ul>
<h5><a class="header" href="#常用库函数介绍补充" id="常用库函数介绍补充">常用库函数介绍(补充)</a></h5>
<ul>
<li>
<p>System.IO 包含对一系列系统调用的支持，比如各种文件操作</p>
<ul>
<li>FileStream</li>
<li>StreamReader 与 StreamWriter 进行文本文件读写</li>
<li>BinaryReader 和 BinaryWriter 类用于二进制文件的读写</li>
<li>DirectoryInfo 类和 FileInfo 类用于进行windows文件系统的操作</li>
</ul>
</li>
<li>
<p>System.Linq 使用一定格式的语句查询和筛选可迭代对象</p>
</li>
<li>
<p>System.Text 包含一系列编解码相关的功能</p>
</li>
<li>
<p>System.Text.RegularExpressions; 包含正则表达式的基类Regex</p>
</li>
<li>
<p>System.Threading 提供启用多线程的类和接口.</p>
</li>
<li>
<p><strong>事件、异步、多线程... 未完待续</strong></p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../OS/OS.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../CSharp/CS-Learning2-MultiThread.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../OS/OS.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../CSharp/CS-Learning2-MultiThread.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
