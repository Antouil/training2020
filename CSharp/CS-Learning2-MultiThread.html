<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CSharp2 - EESAST Training 2020</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../git/git.html"><strong aria-hidden="true">2.</strong> Git</a></li><li class="chapter-item expanded "><a href="../web/web.html"><strong aria-hidden="true">3.</strong> Web</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../web/html&css.html"><strong aria-hidden="true">3.1.</strong> HTML&amp;CSS</a></li><li class="chapter-item expanded "><a href="../web/js&ts.html"><strong aria-hidden="true">3.2.</strong> JS&amp;TS</a></li><li class="chapter-item expanded "><a href="../web/react.html"><strong aria-hidden="true">3.3.</strong> React + antd 入门</a></li><li class="chapter-item expanded "><a href="../web/backend.html"><strong aria-hidden="true">3.4.</strong> 后端技术栈入门（Node.js + Express + MongoDB</a></li></ol></li><li class="chapter-item expanded "><a href="../linux-webserver/linux.html"><strong aria-hidden="true">4.</strong> Linux</a></li><li class="chapter-item expanded "><a href="../docker/docker.html"><strong aria-hidden="true">5.</strong> Docker</a></li><li class="chapter-item expanded "><a href="../OS/OS.html"><strong aria-hidden="true">6.</strong> 操作系统</a></li><li class="chapter-item expanded "><a href="../CSharp/CS-Learning1-Basic.html"><strong aria-hidden="true">7.</strong> CSharp1</a></li><li class="chapter-item expanded "><a href="../CSharp/CS-Learning2-MultiThread.html" class="active"><strong aria-hidden="true">8.</strong> CSharp2</a></li><li class="chapter-item expanded "><a href="../unity/unity.html"><strong aria-hidden="true">9.</strong> Unity</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">EESAST Training 2020</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/eesast/training2020" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#c课程2事件异步多线程" id="c课程2事件异步多线程">C#课程2（事件、异步、多线程）</a></h1>
<ul>
<li><a href="#c%E8%AF%BE%E7%A8%8B2%E4%BA%8B%E4%BB%B6%E5%BC%82%E6%AD%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B">C#课程2（事件、异步、多线程）</a>
<ul>
<li><a href="#%E4%B8%80%E4%BA%8B%E4%BB%B6event">一、事件（event）</a></li>
<li><a href="#%E4%BA%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B">二、多线程</a>
<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B">1. 简介</a></li>
<li><a href="#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2. 常用方法</a></li>
<li><a href="#3-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7">3. 常用属性</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">三、异步编程</a>
<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B-1">1. 简介</a></li>
<li><a href="#2-task%E4%BB%8B%E7%BB%8D">2. Task介绍</a></li>
<li><a href="#3-async-%E5%92%8C-await">3. async 和 await</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E9%94%81">四、锁</a>
<ul>
<li><a href="#%E8%AF%BB%E5%86%99%E9%94%81">读写锁</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F">死锁的产生</a></li>
<li><a href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家就餐问题</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6">死锁产生的条件</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3">死锁的解决</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">五、原子操作</a></li>
<li><a href="#%E5%85%ADc-%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88">六、C# 并发集合</a></li>
<li><a href="#%E4%B8%83c%E5%AE%9A%E6%97%B6%E5%99%A8">七、C#定时器</a>
<ul>
<li><a href="#systemthreadingtimer">System.Threading.Timer</a></li>
<li><a href="#systemtimerstimer">System.Timers.Timer</a></li>
</ul>
</li>
<li><a href="#%E5%85%ABc-%E7%BA%BF%E7%A8%8B%E6%B1%A0">八、C# 线程池</a></li>
</ul>
</li>
</ul>
<hr />
<h2><a class="header" href="#一事件event" id="一事件event">一、事件（event）</a></h2>
<p>通俗来讲，事件是一种广播机制</p>
<p>比如某个组件订阅了一个事件，那么在这个事件被触发的时候组件会收到通知。</p>
<p>例：小明家里有一部电话，有一个正在烧水的热水壶，电话响了（这是一个event）就会触发小明接电话（这是一个方法）这个动作。（*注：这部分代码参考Event.cs）</p>
<p>事件可以实现底层程序集调用高层程序集的方法。并且在调用的时候可以向高层程序集的方法传入参数。</p>
<p>例：我写了一个库，这个库给出一个Read的事件，这个事件会在控制台输入字符串的时候被调用。（*注：这部分代码参考Event2.cs）</p>
<hr />
<h2><a class="header" href="#二多线程" id="二多线程">二、多线程</a></h2>
<h3><a class="header" href="#1-简介" id="1-简介">1. 简介</a></h3>
<p>进程是操作系统执行程序的基本单位</p>
<p>一个进程拥有多个线程，这些线程之间资源共享。</p>
<p>使用线程进行并发式编程。</p>
<p>C#提供了完整的多线程库</p>
<h3><a class="header" href="#2-常用方法" id="2-常用方法">2. 常用方法</a></h3>
<p>以下代码显示了如何创建一个线程</p>
<pre><code class="language-csharp">using System.Threading; // 包含多线程需要的库

public static void Function() // 一个需要被线程调用的函数
{
    Console.WriteLine(&quot;Function !&quot;);
}

Thread t = new Thread(Function); // 用Function函数初始化线程
</code></pre>
<p>上面的代码并没有让线程运行，如果要让线程开始运行，需要调用 Start() 方法。</p>
<pre><code class="language-csharp">t.Start();
</code></pre>
<p>如果Function的定义修改为如下</p>
<pre><code class="language-csharp">public static void Function(string str);
</code></pre>
<p>那么在Start()方法中就要传入参数。</p>
<pre><code class="language-csharp">t.Start(&quot;Hello World&quot;);
</code></pre>
<p>使用Sleep()方法可以暂停线程一段时间，单位为毫秒。</p>
<pre><code class="language-csharp">Thread.Sleep(1000) // 线程停顿1秒
</code></pre>
<p>使用Join()方法可以阻塞当前线程，等待某一个线程执行完毕后再进行后面的任务。比如下面的代码，展示了Join()方法的阻塞作用</p>
<pre><code class="language-csharp">public static void Function()
{
    for (int i = 0; i &lt; 10; i++)
    {
        Thread.Sleep(200);
        Console.WriteLine(&quot;Function !&quot;);
    }
}
public static void Run()
{
    Thread t = new Thread(Function);
    t.Start();
    Thread.Sleep(500);
    t.Join(); // 这里阻塞了Run()方法所在线程，等待t执行完毕
    Console.WriteLine(&quot;Finish !&quot;);
}
</code></pre>
<p>注意！非常不建议使用Suspend()、Abort()等方法在线程外部暂停或终止一个线程。</p>
<h3><a class="header" href="#3-常用属性" id="3-常用属性">3. 常用属性</a></h3>
<ul>
<li>IsBackground 属性，显示一个线程是否为后台线程。</li>
<li>如果一个线程为后台线程，那么程序不会等待这个线程执行完毕；如果一个线程是前台线程，程序会等待线程执行完毕再退出。</li>
<li>IsAlive 属性，显示一个线程是否正在运行。</li>
<li>IsThreadPoolThread 属性，显示线程是否属于托管线程池。</li>
</ul>
<p>下面的代码展示了如何控制一个线程是否为后台线程</p>
<pre><code class="language-csharp">new Thread(() =&gt;
{
    for (int i = 0; i &lt; 10; i++)
    {
        Thread.Sleep(300);
        Console.WriteLine(&quot;Thread1 : &quot; + i);
    }
})
{ IsBackground = true }.Start();
new Thread(() =&gt;
{
for (int i = 0; i &lt; 6; i++)
{
    Thread.Sleep(300);
    Console.WriteLine(&quot;Thread2 : &quot; + i);
}
})
{ IsBackground = false }.Start();
</code></pre>
<hr />
<h2><a class="header" href="#三异步编程" id="三异步编程">三、异步编程</a></h2>
<h3><a class="header" href="#1-简介-1" id="1-简介-1">1. 简介</a></h3>
<p>C# 引入了async和await关键字后，异步编程变得十分方便</p>
<p>实际上异步编程也是多线程的一种，只不过不需要手动创建线程，线程从线程池中被创建</p>
<p>例：比如我们在处理UI和按钮单击时，需要运行一个长时间运行的方法，比如读取一个大文件，如果采用同步编程，整个程序必须等待这个任务完成才能执行其他任务。</p>
<h3><a class="header" href="#2-task介绍" id="2-task介绍">2. Task介绍</a></h3>
<p>使用Task可以很方便地创建一个任务并运行，下面的代码展示了如何创建任务。</p>
<pre><code class="language-csharp">Task.Run(Method1);
</code></pre>
<p>还可以采用其他形式创建任务</p>
<pre><code class="language-csharp">Task task = new Task(Method1);
task.Start();
</code></pre>
<p>还可以采用Factory创建并运行任务</p>
<pre><code class="language-csharp">Task.Factory.StartNew(Method1);
</code></pre>
<p>Task的生命周期：Task.Status</p>
<p>Task的生命周期有如下几种状态：</p>
<ul>
<li>Created : 已经被创建但还未开始运行</li>
<li>Running : 正在运行</li>
<li>RanToCompletion : 执行完毕</li>
</ul>
<p>下面的代码展示了Task的生命周期：</p>
<pre><code class="language-csharp">public static void Method1()
{
    for (int i = 0; i &lt; 5; i++)
    {
        Thread.Sleep(200);
        Console.WriteLine(&quot;Method1 : &quot; + i);
    }
}
public static void Run()
{
    Task task = new Task(Method1);
    Console.WriteLine(task.Status);
    task.Start();
    for (int i = 0; i &lt; 7; i++)
    {
        Thread.Sleep(200);
        Console.WriteLine(task.Status);
    }
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-csharp">Created
Running
Method1 : 0
Method1 : 1
Running
Running
Method1 : 2
Method1 : 3
Running
Running
Method1 : 4
RanToCompletion
RanToCompletion
</code></pre>
<p>Task的任务控制，可以控制多个Task的执行顺序</p>
<p>Task.Wait()方法等待任务执行完毕</p>
<pre><code class="language-csharp">Task task1 = new Task(Method1);
task1.Start();
task.Wait(); // 等待任务执行完毕
Console.WriteLine(&quot;task Finish&quot;);
</code></pre>
<p>Task.WaitAll()等待所有任务执行完毕</p>
<pre><code class="language-csharp">Task task1 = new Task(Method1);
task1.Start();
Task task2 = new Task(Method2);
task2.Start();
Task.WaitAll(task1, task2);
Console.WriteLine(&quot;task Finish&quot;);
</code></pre>
<p>Task.WaitAny() 等待任一任务执行完毕</p>
<pre><code class="language-csharp">Task task1 = new Task(Method1);
task1.Start();
Task task2 = new Task(Method2);
task2.Start();
Task.WaitAny(task1, task2);
Console.WriteLine(&quot;task Finish&quot;);
</code></pre>
<p>Task 返回值 Task&lt; TResult &gt;</p>
<p>任何一个异步Task都可以返回一个值，下面的代码展示了如何获取Task的返回值。</p>
<pre><code class="language-csharp">public static string MethodReturn()
{
    for (int i = 0; i &lt; 5; i++)
    {
        Thread.Sleep(200);
        Console.WriteLine(&quot;MethodReturn : &quot; + i);
    }
    return &quot;MethodReturn finish&quot;;
}
Task&lt;string&gt; taskReturn = new Task&lt;string&gt;(MethodReturn);
taskReturn.Start();
Console.WriteLine(&quot;Task finish with : &quot; + taskReturn.Result);
</code></pre>
<p>可以看到只需要调用Task.Result就可以获取Task的返回值，并且在尝试获得Task的返回值时会自动阻塞当前线程，直到Task结束。</p>
<h3><a class="header" href="#3-async-和-await" id="3-async-和-await">3. async 和 await</a></h3>
<p>await 和字面意思一样，就是等待，下面的代码展示了等待一个任务执行完毕</p>
<pre><code class="language-csharp">public static async void Run()
{
    await Task.Run(Method1);
    Console.WriteLine(&quot;Task1 finish &quot;);
}
</code></pre>
<p>await 更大的用处是等待一个有返回值的Task，如下代码所示：</p>
<pre><code class="language-csharp">public static async void Run()
{
    Task&lt;string&gt; task = new Task&lt;string&gt;(MethodReturn);
    task.Start();
    Console.WriteLine(&quot;Task1 finish with : &quot; + await task);
}
</code></pre>
<p>async 的意思也和字面意思完全一样，就是表明一个方法是异步方法，下面展示了一个异步方法：</p>
<pre><code class="language-csharp">public static async void TestAsync()
{
    await Task.Run(
        () =&gt;
        {
            for (int i = 0; i &lt; 5; i++)
            {
                Thread.Sleep(200);
                Console.WriteLine(&quot;TestAsync : &quot; + i);
            }
        });
}
public static async void Run()
{
    TestAsync();
    Console.WriteLine(&quot;Task1 finish  &quot;);
}
</code></pre>
<p>可以注意到凡是方法体里出现了await关键字的，方法定义必然要出现async关键字，这是显然的，因为凡是有await关键字的方法必为异步方法。</p>
<p>需要注意的是如果一个被async修饰的方法里面没有await关键字的话，那么这个方法和同步方法没有区别。</p>
<p>一个async方法里面的异步操作仅出现在await关键字之后。</p>
<pre><code class="language-csharp">public static async void TestAsync()
{
    for (int i = 0; i &lt; 3; i++)
    {
        Thread.Sleep(200);
        Console.WriteLine(&quot;Sync : &quot; + i);
    }
    await Task.Run(
        () =&gt;
        {
            for (int i = 0; i &lt; 5; i++)
            {
                Thread.Sleep(200);
                Console.WriteLine(&quot;TestAsync : &quot; + i);
            }
        });
}
public static async void Run()
{
    TestAsync();
    Console.WriteLine(&quot;Task1 finish  &quot;);
}
</code></pre>
<p>因为async方法为异步方法，所以调用async方法的时候常常也使用await。</p>
<pre><code class="language-csharp">public static async Task&lt;string&gt; AsyncReturn()
{
    await Task.Run(
        () =&gt;
        {
            for (int i = 0; i &lt; 5; i++)
            {
                Thread.Sleep(200);
                Console.WriteLine(&quot;AsyncReturn : &quot; + i);
            }
        });
    return &quot;AsyncReturn finish&quot;;
}
public static async void Run()
{
    var str = await AsyncReturn();
    Console.WriteLine(&quot;Task1 finish with : &quot; + str);
}
</code></pre>
<p>注意：async方法的返回值只能为void、Task、Task&lt; TResult &gt;，不能为其他</p>
<hr />
<h2><a class="header" href="#四锁" id="四锁">四、锁</a></h2>
<p>多线程编程过程中常常会出现多个线程同时访问一个资源的情况，这个时候就需要用到锁，把共享的资源锁起来。</p>
<p>一个不使用锁的例子：</p>
<pre><code class="language-csharp">int num = 0;
Task.Run(
() =&gt;
{
    for (int i = 0; i &lt; 1000; i++)
    {
        num++;
    }
    Console.WriteLine(&quot;Thread 1 : &quot; + num);
}
);
Task.Run(
() =&gt;
{
    for (int i = 0; i &lt; 1000; i++)
    {
        num++;
    }
    Console.WriteLine(&quot;Thread 2 : &quot; + num);
}
);
</code></pre>
<p>锁的使用非常简单，只需要使用 lock 关键字就可以锁住一个对象，一个对象同时只允许一个线程访问，其他线程在这个期间会被阻塞。</p>
<pre><code class="language-csharp">int num = 0;
object numlock = new object();
Task.Run(
    () =&gt;
    {
        for (int i = 0; i &lt; 1000; i++)
        {
            lock (numlock)
                num++;
        }
        lock (numlock)
            Console.WriteLine(&quot;Thread 1 : &quot; + num);
    }
);
Task.Run(
    () =&gt;
    {
        for (int i = 0; i &lt; 1000; i++)
        {
            lock (numlock)
                num++;
        }
        lock (numlock)
            Console.WriteLine(&quot;Thread 2 : &quot; + num);
    }
);
</code></pre>
<p>下面这段代码展示了锁是如何阻塞线程的：</p>
<pre><code class="language-csharp">object tasklock = new object();
Task.Run(() =&gt;
    {
        lock (tasklock)
            for (int i = 0; i &lt; 5; i++)
            {
                Thread.Sleep(200);
                Console.WriteLine(&quot;Thread 1&quot;);
            }
    }
);
Task.Run(() =&gt;
    {
        lock (tasklock)
            for (int i = 0; i &lt; 5; i++)
            {
                Thread.Sleep(200);
                Console.WriteLine(&quot;Thread 2&quot;);
            }
    }
);
</code></pre>
<p>除了使用 lock 关键字，还可以使用 Moniter 来锁定和释放对象。</p>
<pre><code class="language-csharp">Monitor.Enter(objlock);
Monitor.Exit(objlock);
</code></pre>
<p>注意：</p>
<ul>
<li>应避免锁定 public 对象，否则实例将超出代码的控制范围。</li>
<li>锁定对象应当为 readonly 以免在锁定的过程中发生改变</li>
<li>不能锁定值类型</li>
</ul>
<pre><code class="language-csharp">lock(9) // 错误，不能锁定值类型
lock(this) // 错误，违反了不能锁定 public 对象的规范
lock(&quot;Hello World&quot;) // 错误，相同字符串同一程序中只有一个实例对象，相当于锁定 public 对象。
</code></pre>
<p>下面是正确示例</p>
<pre><code class="language-csharp">private static readonly object objlock = new object();
lock(objlock)
  ...
</code></pre>
<h3><a class="header" href="#读写锁" id="读写锁">读写锁</a></h3>
<p>允许多个线程同时获取读锁，但同一时间只允许一个线程获得写锁</p>
<p>当某个线程进入读取模式时，此时其他线程依然能进入读取模式，假设此时一个线程要进入写入模式，那么他不得不被阻塞。</p>
<p>如果某个线程进入了写入模式，那么其他线程无论是要写入还是读取，都是会被阻塞的。</p>
<pre><code class="language-csharp">ReaderWriterLockSlim rw = new ReaderWriterLockSlim();
int num = 5;
for (int i = 0; i &lt; 5; i++)
{
    int tmp = i;
    Task.Run(() =&gt;
    {
        rw.EnterReadLock();
        for (int j = 0; j &lt; 5; j++)
        {
            
            Thread.Sleep(200);
            Console.WriteLine(&quot;Thread &quot; + tmp + &quot; is reading&quot;);
        }
        rw.ExitReadLock();
    });
}
</code></pre>
<p>上面的代码展示了多个线程可以同时获取读锁。</p>
<pre><code class="language-csharp">ReaderWriterLockSlim rw = new ReaderWriterLockSlim();
int num = 5;
for (int i = 0; i &lt; 5; i++)
{
    int tmp = i;
    Task.Run(() =&gt;
    {
        for (int j = 0; j &lt; 5; j++)
        {
            rw.EnterReadLock();
            Thread.Sleep(200);
            Console.WriteLine(&quot;Thread &quot; + tmp + &quot; is reading&quot;);
            rw.ExitReadLock();
        }
    });
}
Thread.Sleep(400);
Task.Run(() =&gt;
{
    rw.EnterWriteLock();
    for (int j = 0; j &lt; 5; j++)
    {
        Thread.Sleep(200);
        Console.WriteLine(&quot;Thread is writing&quot;);
    }
    rw.ExitWriteLock();
});
</code></pre>
<p>上面的代码展示了当一个线程获取写锁的时候其他线程都被阻塞。</p>
<h3><a class="header" href="#死锁的产生" id="死锁的产生">死锁的产生</a></h3>
<p>考虑下面的程序运行过程：</p>
<p>Thread1 : lock 1 -&gt; attempt to lock 2</p>
<p>Thread2 : lock 2 -&gt; attempt to lock 1</p>
<p>这是一个最简单的死锁例子。两个线程都无法继续运行下去，程序产生了死锁。</p>
<pre><code class="language-csharp">object lock1 = new object();
object lock2 = new object();
Task.Run(() =&gt;
{
    lock (lock1)
    {
        Console.WriteLine(&quot;Thread 1 has lock 1&quot;);
        Thread.Sleep(1);
        Console.WriteLine(&quot;Thread 1 attempt to lock 2&quot;);
        lock (lock2)
        {
            Console.WriteLine(&quot;Thread 1 has lock 2&quot;);
        }
    }
});
Task.Run(() =&gt;
{
    lock (lock2)
    {
        Console.WriteLine(&quot;Thread 2 has lock 2&quot;);
        Thread.Sleep(1);
        Console.WriteLine(&quot;Thread 2 attempt to lock 1&quot;);
        lock (lock1)
        {
            Console.WriteLine(&quot;Thread 2 has lock 1&quot;);
        }
    }
});
</code></pre>
<h3><a class="header" href="#哲学家就餐问题" id="哲学家就餐问题">哲学家就餐问题</a></h3>
<p>有五个哲学家，他们的生活方式是交替地进行思考和进餐。他们共用一张圆桌，分别坐在五张椅子上。</p>
<p>在圆桌上有五个碗和五支筷子，平时哲学家进行思考，饥饿时便试图取用其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐。进餐完毕，放下筷子又继续思考。</p>
<p>死锁的产生：五位哲学家同时饥饿而各自拿起了左边的筷子，当他们试图去拿起右边的筷子时，都将因无筷子而无限期地等待下去。</p>
<h3><a class="header" href="#死锁产生的条件" id="死锁产生的条件">死锁产生的条件</a></h3>
<ol>
<li>互斥条件。即某个资源在一段时间内只能由一个进程占有</li>
<li>不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源</li>
<li>占有且申请条件。进程至少已经占有一个资源，但又申请新的资源</li>
<li>循环等待条件。存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......</li>
</ol>
<h3><a class="header" href="#死锁的解决" id="死锁的解决">死锁的解决</a></h3>
<ol>
<li>打破互斥条件，允许进程同时访问某些资源（废话）</li>
<li>打破不可抢占条件，即允许进程强行从占有者那里夺取某些资源（也是废话）</li>
<li>打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源（很难满足条件）</li>
<li>资源编号，线程在申请资源时，必须按顺序申请（实现简单，常用）</li>
<li>银行家算法（有一定的限制条件）</li>
</ol>
<p>资源编号策略：</p>
<ul>
<li>1 号哲学家拿起 1 号筷子</li>
<li>2 号哲学家拿起 2 号筷子</li>
<li>3 号哲学家拿起 3 号筷子</li>
<li>4 号哲学家拿起 4 号筷子</li>
<li>5 号哲学家拿起 ? 号筷子</li>
</ul>
<p>“避免死锁的最好办法，就是不要用锁。” 著名哲学家沃尔兹基说。</p>
<hr />
<h2><a class="header" href="#五原子操作" id="五原子操作">五、原子操作</a></h2>
<p>就如其字面意思，原子操作就是计算机中不可再分割的操作。</p>
<p>C# 提供了一个原子操作库 Interlocked ，可以使用 Interlocked 把常见的操作转化为原子操作。</p>
<p>常见的操作有 i++ （自增操作），如果使用 lock 则系统开销过大，不值得使用，可以使用原子操作进行改写。</p>
<pre><code class="language-csharp">int num = 0;
Task.Run(
    () =&gt;
    {
        for (int i = 0; i &lt; 1000; i++)
        {
            Interlocked.Increment(ref num);
        }
        Console.WriteLine(&quot;Thread 1 : &quot; + num);
    }
);
Task.Run(
    () =&gt;
    {
        for (int i = 0; i &lt; 1000; i++)
        {
            Interlocked.Increment(ref num);
        }
        Console.WriteLine(&quot;Thread 2 : &quot; + num);
    }
);
</code></pre>
<p>除了 Increment 之外，还有许多其他原子操作，比如：</p>
<pre><code class="language-csharp">Add(ref T a, T b); // a = a + b
Exchange(ref T a, T b); // a = b
CompareExchange(ref T a, T b, int c); // if(b == c) a = b;
Decrement(ref T a); // a--
</code></pre>
<hr />
<h2><a class="header" href="#六c-并发集合" id="六c-并发集合">六、C# 并发集合</a></h2>
<p>C# 默认的集合并不是线程安全的，当多个线程同时对一个集合作修改时可能会发生异常：</p>
<pre><code class="language-csharp">List&lt;int&gt; l = new List&lt;int&gt;();
Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10000; i++)
    {
        l.Add(i);
    }
    Thread.Sleep(10);
    Console.WriteLine(l.Count);
});
Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10000; i++)
    {
        l.Add(i);
    }
    Thread.Sleep(10);
    Console.WriteLine(l.Count);
});
</code></pre>
<p>C# 提供了多个线程安全集合类，这些线程安全集合都是无锁的，能够支持高效的多线程操作</p>
<p>下面以 ConcurrentQueue&lt; T &gt; 为例展示一下线程安全集合类的用法：</p>
<pre><code class="language-csharp">ConcurrentQueue&lt;int&gt; q = new ConcurrentQueue&lt;int&gt;(); // 新建一个线程安全队列。
q.Enqueue(9); // 数字 9 入队
q.TryDequeue(out int temp); // 从队列头取出一个数
Console.WriteLine(temp);
</code></pre>
<p>注意，Concurrent 集合通常都有 Try 方法，凡是 Try 方法都不一定能执行成功，并且都会返回一个布尔值，用来显示 Try 方法是否执行成功。</p>
<p>Concurrent 命名空间下没有 HashSet&lt; T &gt; 的对应线程安全集合，但可以用 ConcurrentDictionry&lt; T, byte &gt; 来代替。</p>
<p>除了 Concurrent 命名空间下的集合，C# 还提供了 BlockingCollection 阻塞集合。这个集合的特点是当集合为空时，想要从集合里取出元素会被阻塞</p>
<pre><code class="language-csharp">BlockingCollection&lt;int&gt; b = new BlockingCollection&lt;int&gt;();
Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10; i++)
    {
        Thread.Sleep(300);
        b.Add(i);
        Console.WriteLine(&quot;Add &quot; + i);
    }
});
Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10; i++)
    {
        Console.WriteLine(&quot;Take &quot; + b.Take());
    }
});
</code></pre>
<p>上面这段代码展示了 BlockingCollection 是如何把线程阻塞的。</p>
<p>利用 BlockingCollection 可以实现事件队列，强制把所有事件放在同一线程里执行。</p>
<pre><code class="language-csharp">BlockingCollection&lt;Action&gt; EventQueue = new BlockingCollection&lt;Action&gt;();
new Thread(() =&gt;
{
    while (true)
        EventQueue.Take()();
}).Start();
</code></pre>
<p>只需要很少的代码就可以实现事件队列的编写。</p>
<p>我们可以用如下代码测试事件队列：</p>
<pre><code class="language-csharp">for (int i = 0; i &lt; 10; i++)
{
    Thread.Sleep(300);
    Task.Run(() =&gt;
    {
        EventQueue.Add(() =&gt;
        {
            Console.WriteLine(DateTime.Now);
        });
    });
}
</code></pre>
<hr />
<h2><a class="header" href="#七c定时器" id="七c定时器">七、C#定时器</a></h2>
<p>C# 里提供了几种定时器的实现方法。</p>
<h3><a class="header" href="#systemthreadingtimer" id="systemthreadingtimer">System.Threading.Timer</a></h3>
<p>下面的代码展示了如何新建一个定时器</p>
<pre><code class="language-csharp">System.Threading.Timer timer = new Timer(
    (o) =&gt;
    {
        Console.WriteLine(&quot;Timer !&quot;);
    }, null, 1000, 200);
</code></pre>
<p>Timer() 的构造方法第一个参数为定时执行的回调函数，第二个参数为传递给回调的参数，第三个参数为 duetime ，即在开始计时前等待多长时间，第四个参数为 period ，即定时器周期。</p>
<p>也可以采用如下代码开始一个定时器：</p>
<pre><code class="language-csharp">System.Threading.Timer timer = new Timer(
    (o) =&gt;
    {
        Console.WriteLine(&quot;Timer !&quot;);
    });
timer.Change(1000, 200);
</code></pre>
<p>上面的定时器在构造时并没有开始运行，在调用 Change() 方法后才开始运行。</p>
<p>System.Threading.Timer 在运行过程中随时可以调用 Change() 方法改变定时器的周期。</p>
<h3><a class="header" href="#systemtimerstimer" id="systemtimerstimer">System.Timers.Timer</a></h3>
<p>System.Timers.Timer 是比 System.Threading.Timer 更加灵活的一种定时器。</p>
<p>下面的代码展示了如何使用 System.Timers.Timer</p>
<pre><code class="language-csharp">System.Timers.Timer timer = new System.Timers.Timer();
timer.Elapsed += (o, e) =&gt;
{
    Console.WriteLine(&quot;Timer !&quot;);
};
timer.Interval = 300;
timer.Enabled = true;
</code></pre>
<p>timer.Elapsed 是一个 event ，每个周期都会被调用。</p>
<p>注意： System.Timers.Timer 比 System.Threading.Timer 更加灵活的地方就在于 Elapsed ，你可以在不重新 new 定时器的情况下改变定时器的回调函数。</p>
<pre><code class="language-csharp">public static void CallBack(Object o, System.Timers.ElapsedEventArgs e)
{
    Console.WriteLine(&quot;Timer !&quot;);
}

System.Timers.Timer timer = new System.Timers.Timer();
timer.Elapsed += CallBack;
timer.Interval = 300;
timer.Enabled = true;
Thread.Sleep(1200);
timer.Elapsed -= CallBack; // 这里把 CallBack 函数剥离 Elapsed
</code></pre>
<p>System.Timers.Timer 的一些属性：</p>
<pre><code class="language-csharp">bool Enabled; // 定时器是否正在运行
bool AutoReset; // 定时器是否周期执行，若为false，则表明定时器只执行一次。
int Interval; // 定时器执行的周期
</code></pre>
<hr />
<h2><a class="header" href="#八c-线程池" id="八c-线程池">八、C# 线程池</a></h2>
<p>线程池的作用是避免重复创建和销毁线程。</p>
<p>程序里常常会创建大量线程，但这些线程只使用了一小段时间就被挂起或进入休眠，一直等到程序结束都不会再使用。</p>
<p>C# 提供了线程池用于线程复用，当一个异步方法想要调用线程来运行，可以先到线程池里看看有没有空闲线程</p>
<p>如果有空闲线程则调用空闲线程完成任务。</p>
<pre><code class="language-csharp">ThreadPool.QueueUserWorkItem(
    (o) =&gt;
    {
        for (int i = 0; i &lt; 5; i++)
        {
            Thread.Sleep(300);
            Console.WriteLine(&quot;Thread Pool !&quot;);
        }
    }
);
</code></pre>
<p>调用线程池非常简单，只要像上面这段代码一样把一个 Callback 塞进线程就行。</p>
<p>线程池在创建之初会有一个最小线程数，这与计算机的 CPU 核心数有关，可以用 ThreadPool.GetMinThreads() 方法获取。</p>
<pre><code class="language-csharp">ThreadPool.GetMinThreads(out int workerThreads, out int IOThreads);
Console.WriteLine(workerThreads + &quot;  &quot; + IOThreads);
</code></pre>
<p>需要注意的是，Task 和 Timer 也是默认调用线程池里的线程来完成工作的。</p>
<p>如果线程池中的线程被用完了怎么办呢？这个时候系统会停顿 1 秒钟，观察线程池中其他线程是否执行完毕，如果有线程执行完毕的话则调用这个线程，如果没有的话则对线程池进行扩容，增加一个线程。</p>
<pre><code class="language-csharp">for (int i = 0; i &lt; 12; i++)
{
    int tmp = i;
    Task.Run(() =&gt;
    {
        Console.WriteLine(&quot;Thread &quot; + tmp);
        Console.ReadKey();
    });
}
</code></pre>
<p>上面这段代码展示了线程池是如何进行扩容的。</p>
<p>我们可以用 SetMinThreads() 方法设置线程池的最小线程数</p>
<pre><code class="language-csharp">ThreadPool.SetMinThreads(16, 16);
</code></pre>
<p>设置了最小线程数后再执行上面的代码则不会出现新的任务要等待 1 秒的情况</p>
<p>我们也可以用 SetMaxThreads() 方法设置线程池的最小线程数</p>
<pre><code class="language-csharp">ThreadPool.SetMaxThreads(8, 8);
</code></pre>
<p>像这样设置了线程池的最大线程数后，上面的代码中 Thread 8 ~ 11 则永远不会被执行，因为 Thread 8 ~ 11 要等到线程池有空闲时才能执行。</p>
<p>线程池的其他方法：</p>
<pre><code class="language-csharp">ThreadPool.GetAvailableThreads(out int workerThreads, out int completionPortThreads); // 获取线程池中的空闲线程。
ThreadPool.ThreadCount; // 获取线程池中的线程数目
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../CSharp/CS-Learning1-Basic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../unity/unity.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../CSharp/CS-Learning1-Basic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../unity/unity.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
