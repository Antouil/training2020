<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>EESAST Training 2020</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="git/git.html"><strong aria-hidden="true">2.</strong> Git</a></li><li class="chapter-item expanded "><a href="web/web.html"><strong aria-hidden="true">3.</strong> Web</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="web/html&css.html"><strong aria-hidden="true">3.1.</strong> HTML&amp;CSS</a></li><li class="chapter-item expanded "><a href="web/js&ts.html"><strong aria-hidden="true">3.2.</strong> JS&amp;TS</a></li><li class="chapter-item expanded "><a href="web/react.html"><strong aria-hidden="true">3.3.</strong> React + antd 入门</a></li></ol></li><li class="chapter-item expanded "><a href="linux-webserver/linux.html"><strong aria-hidden="true">4.</strong> Linux</a></li><li class="chapter-item expanded "><a href="docker/docker.html"><strong aria-hidden="true">5.</strong> Docker</a></li><li class="chapter-item expanded "><a href="OS/OS.html"><strong aria-hidden="true">6.</strong> 操作系统</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">EESAST Training 2020</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/eesast/training2020" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>本文档为清华电子系学生科协 2020 年暑期培训<a href="https://github.com/eesast/training2020">仓库</a>中各部分内容介绍及相关依赖的简要安装说明。</p>
<p>培训所用的文档、教学用 PPT 及相关仓库与依赖链接基本上可以在仓库中找到。</p>
<blockquote>
<p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">EESAST Training 2020</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/eesast/training2020" property="cc:attributionName" rel="cc:attributionURL">EESAST</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享 署名-相同方式共享 4.0 国际 许可协议</a>进行许可。
多数内容将以 CC-BY-SA 4.0 进行许可，部分培训内容的作者可能会有特殊许可，若有需要还请注意。</p>
</blockquote>
<p>培训内容主要分为三个大部分：</p>
<ul>
<li>基础工具 Git, Docker</li>
<li>队式开发技术栈</li>
<li>网站开发技术栈</li>
</ul>
<p>具体内容还请参阅各章说明</p>
<h1><a class="header" href="#git" id="git">Git</a></h1>
<p>Git 是一个分布式版本管理系统，虽然设计上可能存在一些问题，但不妨碍其成为如今使用最广的地位。软件部的开发采取 Git 进行版本管理，也推荐大家将 Git 应用到各种需要版本管理的地方。</p>
<p><a href="git/../../../basic%20tool/git.pptx">课件</a></p>
<h2><a class="header" href="#参考链接" id="参考链接">参考链接</a></h2>
<ul>
<li><a href="https://github.com/pcottle/learnGitBranching">pcottle/learnGitBranching</a></li>
<li><a href="https://github.com/k88hudson/git-flight-rules">k88hudson/git-flight-rules</a></li>
</ul>
<h1><a class="header" href="#web" id="web">web</a></h1>
<p>这一章将基于 EESAST 目前网站方面使用的技术进行培训，内容主要为以下几个部分：</p>
<ul>
<li>Html, CSS, JavaScript/TypeScript 基础</li>
<li>Node.js 与包管理</li>
<li>React + antd</li>
<li>Restful API 与 Express</li>
<li>GraphQL + Hasura + Apollo</li>
<li>数据库 MongoDB 和 PostgreSQL</li>
<li>Web测试 Mocha + Chai</li>
<li>CI/CD</li>
</ul>
<p>具体内容安排请参照各小节说明</p>
<p>需要用到的工具及相关链接如下：</p>
<ul>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a></li>
<li>Node.js
<ul>
<li><a href="https://nodejs.org/en/download/">官方网站</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/nodejs-release/">清华 tuna 镜像</a>
<ul>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/nodejs-release/">tuna 镜像帮助页面</a></li>
</ul>
</li>
<li><a href="https://mirrors.bfsu.edu.cn/nodejs-release/">北京外国语大学镜像</a>
<ul>
<li><a href="https://mirrors.bfsu.edu.cn/help/nodejs-release/">北外镜像帮助页面</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://yarn.bootcss.com/docs/getting-started/">Yarn</a></li>
<li><a href="https://react.docschina.org/">React</a></li>
<li><a href="https://ant.design/index-cn">Ant Design</a></li>
<li><a href="https://www.expressjs.com.cn/">Express</a></li>
<li><a href="https://graphql.org/">GraphQL</a></li>
<li><a href="https://hasura.io/">Hasura</a></li>
<li><a href="https://www.apollographql.com/">Apollo</a></li>
<li><a href="https://www.mongodb.com/">MongoDB</a></li>
<li><a href="https://www.postgresql.org/">PostgreSQL</a></li>
<li><a href="https://mochajs.org/">Mocha</a></li>
<li><a href="https://www.chaijs.com/">Chai</a></li>
<li><a href="https://help.github.com/en/actions">GitHub Actions</a></li>
</ul>
<h1><a class="header" href="#htmlcss-入门" id="htmlcss-入门">HTML&amp;CSS 入门</a></h1>
<blockquote>
<p>这里介绍的知识非常基础，因为网站组的同学们在后面写网站的时候很少直接写 HTML&amp;CSS（尤其是 HTML），这里讲只是为了让大家简单了解下网页的机制</p>
</blockquote>
<blockquote>
<p>本文档参考<a href="https://developer.mozilla.org/zh-CN/">MDN</a>完成，希望深入学习的同学可以参考</p>
</blockquote>
<h2><a class="header" href="#html" id="html">HTML</a></h2>
<blockquote>
<p>参考：https://developer.mozilla.org/zh-CN/docs/Web/HTML</p>
</blockquote>
<h3><a class="header" href="#基础" id="基础">基础</a></h3>
<p>HTML (Hyper Text Markup Language) 不是一门编程语言，而是一种用来告知浏览器如何组织页面的标记语言。HTML 可复杂、可简单，一切取决于开发者。它由一系列的元素（elements）组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。 一对标签（ tags）可以为一段文字或者一张图片添加超链接，将文字设置为斜体，改变字号，等等。</p>
<p>最简单的一个内容是这样的</p>
<p>欢迎大家加入科协</p>
<pre><code class="language-html">&lt;p&gt;欢迎大家加入科协&lt;/p&gt;
</code></pre>
<p>这是一个段落(p)元素，一个 html 元素的组成分为</p>
<ol>
<li><strong>开始标签</strong>（Opening tag）：包含元素的名称，被左、右角括号所包围。表示元素从这里开始或者开始起作用</li>
<li><strong>结束标签</strong>（Closing tag）：与开始标签相似，只是其在元素名之前包含了一个斜杠。这表示着元素的结尾 —— 在本例中即段落在此结束。初学者常常会犯忘记包含结束标签的错误，这可能会产生一些奇怪的结果。</li>
<li><strong>内容</strong>（Content）：元素的内容，本例中就是所输入的文本本身。</li>
<li><strong>元素</strong>（Element）：开始标签、结束标签与内容相结合，便是一个完整的元素。</li>
</ol>
<p>HTML 元素可以进行嵌套，比如</p>
<p><em>欢迎</em>大家加入<strong>科协</strong></p>
<pre><code class="language-html">&lt;p&gt;&lt;em&gt;欢迎&lt;/em&gt;大家加入&lt;strong&gt;科协&lt;/strong&gt;&lt;/p&gt;
</code></pre>
<h3><a class="header" href="#块级元素和内联元素" id="块级元素和内联元素">块级元素和内联元素</a></h3>
<p>块级元素在页面中以块的形式展现 —— 相对于其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现，例如上面的<code>&lt;p&gt;</code></p>
<p>内联元素通常出现在块级元素中并环绕文档内容的一小部分，而不是一整个段落或者一组内容。内联元素不会导致文本换行：它通常出现在一堆文字之间例如超链接元素<code>&lt;a&gt;</code>或者强调元素<code>&lt;em&gt;</code>和<code>&lt;strong&gt;</code>。</p>
<h3><a class="header" href="#空元素" id="空元素">空元素</a></h3>
<p>不是所有元素都拥有开始标签，内容，结束标签，一些元素只有一个标签，通常用来在此元素所在位置插入/嵌入一些东西，比如<code>&lt;img&gt;</code></p>
<h3><a class="header" href="#属性" id="属性">属性</a></h3>
<p>使用属性来给元素设定额外信息，属性的基本写法为</p>
<pre><code class="language-html">&lt;p class=&quot;foobar&quot;&gt;EESAST&lt;/p&gt;
</code></pre>
<p>用空格与元素名或前一个属性隔开，<code>属性名=&quot;值&quot;</code>（单引号双引号都可）</p>
<p>比较典型的例子就是元素<code>&lt;a&gt;</code>，用来创建链接</p>
<p><a href="https://eesast.com" title="科协官网">EESAST</a></p>
<pre><code class="language-html">&lt;a href=&quot;https://eesast.com&quot; title=&quot;科协官网&quot;&gt;EESAST&lt;/a&gt;
</code></pre>
<h3><a class="header" href="#一个-html-文件的结构" id="一个-html-文件的结构">一个 HTML 文件的结构</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;我的测试站点&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;这是我的页面&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><code>&lt;!DOCTYPE html&gt;</code>: 声明文档类型</li>
<li><code>&lt;html&gt;&lt;/html&gt;</code>: <code>&lt;html&gt;</code>元素。这个元素包裹了整个完整的页面，是一个根元素。</li>
<li><code>&lt;head&gt;&lt;/head&gt;</code>: <code>&lt;head&gt;</code>元素.</li>
<li><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>: 元数据，在这里是设置文档使用 utf-8 字符集编码，也可以像<code>&lt;meta name=&quot;author&quot; content=&quot;Chris Mills&quot;&gt;</code>这样用 name 和 content 来设置其他信息，当然在不同的应用场景可以设置很多不同的元数据</li>
<li><code>&lt;title&gt;&lt;/title&gt;</code>: 设置页面标题</li>
<li><code>&lt;body&gt;&lt;/body&gt;</code>: <code>&lt;body&gt;</code>元素， 包含了你访问页面时所有显示在页面上的内容</li>
</ul>
<h3><a class="header" href="#在-html-中应用-css-和-javascript" id="在-html-中应用-css-和-javascript">在 HTML 中应用 CSS 和 JavaScript</a></h3>
<p>对于 CSS，需要加入一个<code>&lt;link&gt;</code>元素，rel=&quot;stylesheet&quot;表明这是文档的样式表，而 href 包含了样式表文件的路径，这个元素一般放在<code>&lt;head&gt;</code>里</p>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;my-css-file.css&quot; /&gt;
</code></pre>
<p>对于 js 脚本，加入<code>&lt;script&gt;</code>元素，src 为脚本的路径。<code>&lt;script&gt;</code>部分没必要非要放在文档头部，实际上，把它放在文档的尾部<code>&lt;/body&gt;</code>标签之前是一个更好的选择，这样可以确保在加载脚本之前浏览器已经解析了 HTML 内容</p>
<pre><code class="language-html">&lt;script src=&quot;my-js-file.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>这里 script 元素没有内容，但他不是一个空元素，你也可以直接把脚本写在元素里</p>
<h3><a class="header" href="#html-的基本布局" id="html-的基本布局">HTML 的基本布局</a></h3>
<ul>
<li><code>&lt;header&gt;</code>：页眉。</li>
<li><code>&lt;nav&gt;</code>：导航栏。</li>
<li><code>&lt;main&gt;</code>：主内容。主内容中还可以有各种子内容区段，可用<code>&lt;article&gt;</code>、<code>&lt;section&gt;</code> 和<code>&lt;div&gt;</code>等元素表示。</li>
<li><code>&lt;aside&gt;</code>：侧边栏，经常嵌套在<code>&lt;main&gt;</code>中。</li>
<li><code>&lt;footer&gt;</code>：页脚。</li>
</ul>
<p>关于完整的 html 元素和属性，可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference">这里</a></p>
<h2><a class="header" href="#css" id="css">CSS</a></h2>
<blockquote>
<p>参考：https://developer.mozilla.org/zh-CN/docs/Web/CSS</p>
</blockquote>
<h3><a class="header" href="#基础-1" id="基础-1">基础</a></h3>
<p>CSS 是一门基于规则的语言，他的基础结构为：由一个选择器开头，后接一对大括号，在大括号内部定义一个或多个形式为 <code>属性(property):值(value);</code> 的声明(declarations)。每个声明都指定了我们所选择元素的一个属性，之后跟一个我们想赋给这个属性的值。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference">这里</a>可以查看所有属性。</p>
<pre><code class="language-css">h1 {
  color: red;
  font-size: 5em;
}

p {
  color: black;
}
</code></pre>
<h4><a class="header" href="#元素选择器" id="元素选择器">元素选择器</a></h4>
<p>使用元素选择器来直接匹配一种 html 元素</p>
<pre><code class="language-css">p {
  color: green;
}
</code></pre>
<p>不同的选择器可以用<code>,</code>隔开来使用多个选择器</p>
<pre><code class="language-html">p, li { color: green; }
</code></pre>
<p>这种直接指定元素类型的写法只能同时应用于所有同类元素，在实际使用的时候是十分不方便的，因此我们还可以使用类名来进一步指定作用的对象。前面说到 HTML 中的元素可以添加属性，这里的类名选择器就对应标签中的<code>class</code>属性，比如</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;项目一&lt;/li&gt;
  &lt;li class=&quot;special&quot;&gt;项目二&lt;/li&gt;
  &lt;li&gt;项目 &lt;em&gt;三&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<pre><code class="language-css">.special {
  color: orange;
  font-weight: bold;
}
</code></pre>
<p>这里指定了属于 special 类的元素进行设置，在在选择器的开头加<code>.</code>即为指定类，当然可以同时指定元素和类</p>
<pre><code class="language-css">li.special,
span.special {
  color: orange;
  font-weight: bold;
}
</code></pre>
<p>此外，我们还可以根据元素的位置来进行选择，在选择器中使用<code>空格</code>来表示包含（嵌套）关系，用<code>+</code>来表示相邻关系，例如</p>
<pre><code class="language-css">li em {
  color: rebeccapurple;
}
</code></pre>
<p>表示选择嵌套在<code>&lt;li&gt;</code>内部的<code>&lt;em&gt;</code></p>
<pre><code class="language-css">h1 + p {
  font-size: 200%;
}
</code></pre>
<p>表示选择跟在<code>&lt;h1&gt;</code>后面的<code>&lt;p&gt;</code></p>
<p>可以尝试下解读这个选择器</p>
<pre><code class="language-css">body h1 + p .special {
  color: yellow;
  background-color: black;
  padding: 5px;
}
</code></pre>
<h3><a class="header" href="#盒模型" id="盒模型">盒模型</a></h3>
<blockquote>
<p>参考：https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model</p>
</blockquote>
<p>在 CSS 中，所有的元素都被一个个的“盒子（box）”包围着，理解这些“盒子”的基本原理，可以帮助我们使用 CSS 实现准确布局、处理元素排列。</p>
<p>CSS 中组成一个块级盒子需要:</p>
<ul>
<li><strong>Content box</strong>: 这个区域是用来显示内容，大小可以通过设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a>.</li>
<li><strong>Padding box</strong>: 包围在内容区域外部的空白区域； 大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a> 相关属性设置。</li>
<li><strong>Border box</strong>: 边框盒包裹内容和内边距。大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 相关属性设置。</li>
<li><strong>Margin box</strong>: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a> 相关属性设置。</li>
</ul>
<p>如下图：</p>
<p><img src="web/./images/box-model.png" alt="box" /></p>
<p>在标准模型中，如果你给盒设置 <code>width</code> 和 <code>height</code>，实际设置的是 <em>content box</em>。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小</p>
<pre><code class="language-css">.box {
  width: 350px;
  height: 150px;
  margin: 25px;
  padding: 25px;
  border: 5px solid black;
}
</code></pre>
<p>可以尝试计算一下这个盒子的大小</p>
<h1><a class="header" href="#javascripttypescript" id="javascripttypescript">JavaScript&amp;TypeScript</a></h1>
<h2><a class="header" href="#javascript" id="javascript">JavaScript</a></h2>
<blockquote>
<p>参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript</p>
<p>更详细的JavaScript学习资料：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</p>
</blockquote>
<h3><a class="header" href="#什么是javascript" id="什么是javascript">什么是JavaScript</a></h3>
<p>JavaScript 是一门跨平台、面向对象的脚本语言，它能使网页可交互(尽管我们这里不会介绍这部分内容)。 JavaScript 堪称世界上被人误解最深的编程语言，虽然常被嘲为“玩具语言”，但在它看似简洁的外衣下，还隐藏着强大的语言特性。 JavaScript 目前广泛应用于众多知名应用中，对于网页和移动开发者来说，深入理解 JavaScript 就尤为必要。</p>
<p>与大多数编程语言不同，JavaScript 没有输入或输出的概念。它是一个在宿主环境（host environment）下运行的脚本语言，任何与外界沟通的机制都是由宿主环境提供的。浏览器是最常见的宿主环境，但在非常多的其他程序中也包含 JavaScript 解释器，如 Adobe Acrobat、Adobe Photoshop、SVG 图像、Yahoo! 的 Widget 引擎，<strong>Node.js</strong>之类的服务器端环境。</p>
<p>我们有时候也会看到ECMAScript或者ES6之类的称呼，ECMA是JavaScript 的标准化组织，ECMAScript是针对 JavaScript 语言制定的标准，之所以不叫 JavaScript，是因为Java和JavaScript的商标都被注册了。因此ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）</p>
<h3><a class="header" href="#javascript基础语法" id="javascript基础语法">JavaScript基础语法</a></h3>
<p>JavaScript 是一种多范式的动态语言，它包含类型、运算符、标准内置（ built-in）对象和方法。在基本语法方面，JavaScript有很多和C/C++相似的地方。JavaScript同样支持函数式编程——<strong>因为它们也是对象，函数也可以被保存在变量中，并且像其他对象一样被传递</strong>。</p>
<h4><a class="header" href="#数据类型" id="数据类型">数据类型</a></h4>
<p>JavaScript 中的类型如下</p>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number"><code>Number</code></a>（数字）</p>
<ul>
<li>3/2=1.5</li>
<li>特殊的值 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a>（Not a Number 的缩写），如果把 <code>NaN</code> 作为参数进行任何数学运算，结果也会是 <code>NaN</code>。<code>NaN</code>如果通过 <code>==</code> 、 <code>!=</code> 、 <code>===</code> 、以及 <code>!==</code>与其他任何值比较都将不相等 -- 包括与其他 NAN值进行比较。必须使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN"><code>Number.isNaN()</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN"><code>isNaN()</code></a> 函数</li>
<li>内置对象 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math"><code>Math</code></a>支持一些高级的计算；</li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a>（字符串）</p>
<ul>
<li>
<p>JavaScript 中的字符串是一串Unicode 字符序列</p>
</li>
<li>
<p><code>'</code>和<code>&quot;</code>皆可</p>
</li>
<li>
<p>可以使用内置函数 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt"><code>parseInt()</code></a>和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseFloat"><code>parseFloat()</code></a>来将字符串转为number</p>
</li>
<li>
<p>可以在字符串字面值上使用字符串对象的所有方法——JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串对象，比如<code>'eesast'.length</code></p>
</li>
<li>
<p>在ES2015中，引入了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings">模板字符串</a>，使用反引号 (` `) 来代替普通字符串中的用双引号和单引号，我们对其最常见的使用就是使用占位符<code>${expression}</code>来在其中插入表达式，例如</p>
<pre><code class="language-javascript">let name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello ${name}, how are you ${time}?`

let a = 5;
let b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
</code></pre>
</li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><code>Boolean</code></a>（布尔）</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a>（符号）（ES2015 新增）</p>
</li>
<li>
<p><code>Object</code></p>
<p>（对象）</p>
<ul>
<li>
<p><code>Function</code>（函数）</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a>（数组）</p>
<ul>
<li>
<p>JavaScript 数组的长度和元素类型都是非固定的，并且其数据在内存中也可以不连续</p>
</li>
<li>
<p>和上面的String类似，可以<code>new Array()</code>来创建数组，当然更简单的是使用字面量来创建<code>let a =['abc',1]; </code>，同样地可以直接对这样创建的数组使用Array对象的方法，例如<code>a.pop();</code></p>
</li>
<li>
<pre><code class="language-javascript">let a = [1, 2, , 4];
console.log(a[2]);
//undefined
a[100]=100;
console.log(a.length);
//101
</code></pre>
</li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Date"><code>Date</code></a>（日期）</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp"><code>RegExp</code></a>（正则表达式）</p>
</li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>（空）</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>（未定义）</p>
</li>
</ul>
<p>可以看到函数和数组也属于对象</p>
<h4><a class="header" href="#注释" id="注释">注释</a></h4>
<p>JavaScript 注释的语法和 C++ 或许多其他语言类似</p>
<pre><code class="language-javascript">// 单行注释

/* 这是一个更长的,
   多行注释
*/
</code></pre>
<h4><a class="header" href="#变量" id="变量">变量</a></h4>
<p>JavaScript有三种声明变量的方式。</p>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var"><code>var</code></a></p>
<p>声明一个变量，可选初始化一个值。</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a></p>
<p>声明一个块作用域的局部变量，可选初始化一个值。</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const"><code>const</code></a></p>
<p>声明一个块作用域的只读常量，必须初始化一个值。</p>
</li>
</ul>
<p>如果声明了一个变量却没有对其赋值，那么这个变量的类型就是 <code>undefined</code></p>
<p><code>const</code>很明显是一个常量，他是只读的，而<code>let</code>与<code>var</code>的主要区别在于，<code>let</code>的作用域是块作用域，而<code>var</code>的作用域是全局或者函数作用域(<code>const</code>也是块作用域)，并且<code>let</code>没有变量提升</p>
<p>最简单的例子如下</p>
<pre><code class="language-javascript">{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1

</code></pre>
<p>有关变量提升，指的是</p>
<pre><code class="language-javascript">// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre>
<p>他们的详细区别可见<a href="https://es6.ruanyifeng.com/#docs/let">此处</a></p>
<h4><a class="header" href="#运算符" id="运算符">运算符</a></h4>
<p>这里只介绍与C++不同的部分</p>
<ul>
<li>
<p>求幂：<code>x**2</code></p>
</li>
<li>
<p>全等和不全等：<code>x===y</code> <code>x!==y</code>比较两个操作数是否相等且类型相同</p>
</li>
<li>
<p>一元的正：即<code>+</code>，如果操作数在之前不是number，试图将其转换为number</p>
</li>
<li>
<p>字符串运算：<code>+</code>可以直接连接两个字符串，并同时会尝试将另一个操作数转换为string</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值</a>：将属性/值从对象/数组中取出,赋值给其他变量，例如</p>
<pre><code class="language-javascript">var a, b, rest;
[a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(a); // 10
console.log(b); // 20
console.log(rest); // [30, 40, 50]

var o = {p: 42, q: true};
var {p, q} = o;
</code></pre>
</li>
</ul>
<h4><a class="header" href="#控制结构" id="控制结构">控制结构</a></h4>
<p>JavaScript 的控制结构与其他类 C 语言类似，在此进行一下罗列</p>
<pre><code class="language-javascript">var name = &quot;kittens&quot;;
if (name == &quot;puppies&quot;) {
  name += &quot;!&quot;;
} else if (name == &quot;kittens&quot;) {
  name += &quot;!!&quot;;
} else {
  name = &quot;!&quot; + name;
}
name == &quot;kittens!!&quot;; // true

//--------------------------------------
while (true) {
  // 一个无限循环！
}

var input;
do {
  input = get_input();
} while (inputIsNotValid(input))
//---------------------------------------
for (var i = 0; i &lt; 5; i++) {
  // 将会执行五次
}

//---------------------------------------
switch(action) {
    case 'draw':
        drawIt();
        break;
    case 'eat':
        eatIt();
        break;
    default:
        doNothing();
}
</code></pre>
<p>JavaScript 也还包括其他两种重要的 for 循环： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of"><code>for</code>...<code>of</code></a></p>
<pre><code class="language-js">for (let value of array) {
  // do something with value
}
</code></pre>
<p>和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for</code>...<code>in</code></a> ：</p>
<pre><code class="language-js">for (let property in object) {
  // do something with object property
}
</code></pre>
<p><code>for ... in</code>是为遍历对象属性而构建的，不建议与数组一起使用</p>
<h4><a class="header" href="#对象" id="对象">对象</a></h4>
<p>JavaScript 中的对象，Object，可以简单理解成“名称-值”对，与我们知道的Python 中的字典（Dictionary）、C/C++ 中的散列表（Hash table）比较相似</p>
<p>有两种简单方法可以创建一个空对象：</p>
<pre><code class="language-js">var obj = new Object();
</code></pre>
<p>和：</p>
<pre><code class="language-js">var obj = {};
</code></pre>
<p>这两种方法在语义上是相同的。第二种更方便的方法叫作“对象字面量（object literal）”法。这种也是 JSON 格式的核心语法，一般我们优先选择第二种方法。</p>
<p>有关对象的访问和成员设置</p>
<pre><code class="language-javascript">person.age = 45
person['name']['last'] = 'Cratchit'
</code></pre>
<p>和大家刚学过的C++类似，这里的对象也有<code>this</code>来指向了当前代码运行时的对象</p>
<p>有关OOP的细节在这里不再介绍，其概念与C++有一些相似性，如果想复习一下OOP并且了解Js中的对象可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects">这里</a></p>
<h4><a class="header" href="#函数" id="函数">函数</a></h4>
<p>最简单的函数定义十分简单</p>
<pre><code class="language-javascript">function add(x, y) {
    var total = x + y;
    return total;
}
</code></pre>
<p>如果调用函数时没有提供足够的参数，缺少的参数会被 <code>undefined</code> 替代，而事实上你传入的参数在一个名为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments"><code>arguments</code></a> 的函数内部对象中，可以像数组一样来访问它，所以你传入了过多的参数也是可以的</p>
<pre><code class="language-javascript">function add() {
    var sum = 0;
    for (var i = 0, j = arguments.length; i &lt; j; i++) {
        sum += arguments[i];
    }
    return sum;
}

add(2, 3, 4, 5); // 14
</code></pre>
<p><code>arguments</code>写起来又丑又长，我们可以用剩余参数来实现相似的功能。剩余参数操作符在函数中以：<strong>...variable</strong> 的形式被使用，它将包含在调用函数时使用的未捕获整个参数列表到这个变量中，例如</p>
<pre><code class="language-javascript">function avg(first, ...args) {
  var sum = first;
  for (let value of args) {
    sum += value;
  }
  return sum / args.length;
}

avg(2, 3, 4, 5); // 3.5
</code></pre>
<blockquote>
<p>和剩余参数操作符长得一样的一个语法是展开语法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">展开语法(Spread syntax)</a>, 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。例如</p>
<pre><code class="language-javascript">let a = [1,2,3];
let b = {1:&quot;1&quot;,2:&quot;2&quot;}

let c = [...a, 4];
//[1, 2, 3, 4]
let d ={...b,3:&quot;3&quot;};
//{1: &quot;1&quot;, 2: &quot;2&quot;, 3: &quot;3&quot;}
</code></pre>
<p>可以看到这种语法在利用已有的数组/对象构造新的数组/对象时十分方便</p>
</blockquote>
<p>JavaScript 也允许在一个函数内部定义函数，它们可以访问父函数作用域中的变量</p>
<pre><code class="language-javascript">function parentFunc() {
  var a = 1;

  function nestedFunc() {
    var b = 4; // parentFunc 无法访问 b
    return a + b;
  }
  return nestedFunc(); // 5
}
</code></pre>
<p>JavaScript 允许创建匿名函数，可以通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>来实现，函数表达式也可以被赋值给一个变量，例如</p>
<pre><code class="language-javascript">//直接调用
(function(x, y){
    return x + y;
})(1,2);
//3

//作为参数传递
setTimeout(function(){console.log('111');},1000);

//赋值给变量
const add = function(x, y){
    return x + y;
}
add(1,2);
//3
</code></pre>
<p>而除了函数表达式之外，我们还有一种更加简洁的方式来创建函数--<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a></p>
<p>引入箭头函数有两个方面的作用：更简短的函数并且不绑定<code>this</code></p>
<p>箭头函数的基本语法为</p>
<pre><code class="language-javascript">(param1, param2, …, paramN) =&gt; { statements } 

(param1, param2, …, paramN) =&gt; expression
//相当于：(param1, param2, …, paramN) =&gt;{ return expression; }

// 当只有一个参数时，圆括号是可选的：
(singleParam) =&gt; { statements }
singleParam =&gt; { statements }

// 没有参数的函数应该写成一对圆括号。
() =&gt; { statements }
</code></pre>
<p>在使用匿名函数的地方箭头函数是十分常见的，箭头函数没有单独的<code>this</code>，不绑定<code>arguments</code>，不能用作构造函数，不太适合作为方法</p>
<h3><a class="header" href="#异步" id="异步">异步</a></h3>
<h4><a class="header" href="#异步基本概念" id="异步基本概念">异步基本概念</a></h4>
<p>通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行。这是令人沮丧的体验，没有充分利用计算机的计算能力 — 尤其是在计算机普遍都有多核CPU的时代，坐在那里等待毫无意义，你完全可以在另一个处理器内核上干其他的工作，同时计算机完成耗时任务的时候通知你。这样你可以同时完成其他工作，这就是<strong>异步编程</strong>的出发点。</p>
<p>具体来说，我们在web编程中，当浏览器里面的一个web应用进行密集运算还没有把控制权返回给浏览器的时候，整个浏览器就像冻僵了一样，即出现了<strong>阻塞</strong>。在实际应用中，这种情况可能是因为向后端请求数据，然后对得到的数据进行处理并展示，在等待数据的时候，就会发生阻塞。而会发生阻塞是因为JavaScript传统上是单线程的，即每个任务顺序执行，只有前面的结束了，后面的才能开始。</p>
<pre><code>Main thread: Task A                   Task B
    Promise:      |__async operation__|
</code></pre>
<p>如上，在异步中，任务B会在任务A执行完之后被唤醒执行，而在这个过程中主线程可以进行其他渲染任务</p>
<h4><a class="header" href="#异步javascript" id="异步javascript">异步JavaScript</a></h4>
<p>我们先来看<a href="https://mdn.github.io/learning-area/javascript/asynchronous/introducing/basic-function.html">同步的JavaScript</a>，即代码顺序执行</p>
<pre><code class="language-javascript">const btn = document.querySelector('button');
btn.addEventListener('click', () =&gt; {
  alert('You clicked me!');

  let pElem = document.createElement('p');
  pElem.textContent = 'This is a newly-added paragraph.';
  document.body.appendChild(pElem);
});
</code></pre>
<p>这个例子里，当我们按下按钮之后，直到关闭alter，后面的页面渲染都没有进行（这里alter只是为了演示，实际应用中不会用到它）</p>
<p>还有一个更实际的例子，我们要请求一张图片，然后将它显示在页面上</p>
<pre><code class="language-javascript">var response = fetch('myImage.png');
var blob = response.blob();
</code></pre>
<p>因为你不知道下载图片会多久，所以第二行代码执行的时候可能报错，因为图像还没有就绪。取代的方法就是，代码必须等到 <code>response</code> 返回才能继续往下执行，而这个时候，你的页面就会看上去像卡住了</p>
<h4><a class="header" href="#回调函数callbacks" id="回调函数callbacks">回调函数(callbacks)</a></h4>
<p>回调函数即作为参数传递给那些在后台执行的其他函数， 当那些后台运行的代码结束，就调用callbacks函数，通知你工作已经完成，或者其他有趣的事情发生了。</p>
<p>比如上面的<code>addEventListener</code>就是一个回调，他在监听的事件发生的时候被调用。但是注意，不是所有的回调函数都是异步的，比如用<code>forEach</code>来遍历数组时，传入的函数就是同步的。</p>
<p>由于我们在后面很少单纯用回调来实现异步（这种写法比较古老而且有一些缺点），这里只展示一个简单的例子</p>
<p><code>setTimeout</code>：在指定的时间后执行一段代码</p>
<p>可以思考一下在同步和异步的情况下这段代码的输出是什么样的</p>
<pre><code class="language-javascript">setTimeout(()=&gt;{console.log('hi');},20000);
console.log('bye');
</code></pre>
<p>有关回调函数，还有一个比较有意思的<a href="http://callbackhell.com/">回调地狱</a>的情况会出现</p>
<h4><a class="header" href="#promise" id="promise">Promise</a></h4>
<p>Promises 是新派的异步代码，现代的web APIs经常用到。先来看一个展示Promise基本语法的例子</p>
<pre><code class="language-js">fetch('products.json').then(function(response) {
  return response.json();
}).then(function(json) {
  products = json;
  initialize();
}).catch(function(err) {
  console.log('Fetch problem: ' + err.message);
});
</code></pre>
<p>这里的<code>fetch()</code> 返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a>. promise 是表示异步操作完成或失败的对象。可以说，它代表了一种中间状态。 本质上，这是浏览器说“我保证尽快给您答复”的方式，因此得名“promise”。而在上面的代码中，跟在promise后面的是</p>
<ul>
<li>两个 <code>then()</code> 块。两者都包含一个回调函数，如果前一个操作成功，该函数将运行，并且每个回调都接收前一个成功操作的结果作为输入，因此可以继续对它执行其他操作。每个 <code>.then()</code>块返回另一个promise，这意味着可以将多个<code>.then()</code>块链接到另一个块上，这样就可以依次执行多个异步操作。</li>
<li>如果其中任何一个<code>then()</code>块失败，则在末尾运行<code>catch()</code>块——与同步<code>try...catch</code>类似，<code>catch()</code>提供了一个错误对象，可用来报告发生的错误类型。</li>
</ul>
<p>Promise 对象本质上表示的是一系列操作的中间状态，或者说是未来某时刻一个操作完成或失败后返回的结果。Promise并不保证操作在何时完成并返回结果，但是保证在当前操作成功后执行您对操作结果的处理代码，或在操作失败后，优雅地处理操作失败的情况。</p>
<p>对比回调，Promise的优点可以从下面的代码中看出（模拟按顺序处理披萨订单）</p>
<p>回调的实现是这样的，就像上面的回调地狱，可读性差</p>
<pre><code class="language-javascript">chooseToppings(function(toppings) {
  placeOrder(toppings, function(order) {
    collectOrder(order, function(pizza) {
      eatPizza(pizza);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);
</code></pre>
<p>而用Promise我们可以这样实现</p>
<pre><code class="language-javascript">chooseToppings()
.then(toppings =&gt; placeOrder(toppings))
.then(order =&gt; collectOrder(order))
.then(pizza =&gt; eatPizza(pizza))
.catch(failureCallback);
</code></pre>
<h4><a class="header" href="#async-await" id="async-await">async await</a></h4>
<p><code>async</code>和<code>await</code>是在ECMAScript 2017中添加的promises的语法糖，使得异步代码更易于编写和后续阅读。</p>
<ul>
<li>
<p>首先，我们使用<code>async</code>关键字，将它放在函数声明之前，将其转换为<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async function</a>。异步函数是一个知道怎样预期 await 关键字可用于调用异步代码可能性的函数。而async函数调用返回的是一个promise</p>
<pre><code class="language-javascript">const hello = async () =&gt; { return &quot;Hello&quot; };
hello();
//Promise {&lt;resolved&gt;: &quot;Hello&quot;}
</code></pre>
<p>当然这个Promise可以像之前提到的一样后接<code>.then()</code>等等来使用。我们只需要在需要异步执行的函数前添加<code>async</code>关键字，JavaScript引擎就可以优化你的程序</p>
</li>
<li>
<p>与<code>awiat</code>关键字结合可以体现出他们的真正优势，<code>awiat</code>可以用在异步函数中，他会使得暂停代码在该行上，直到promise完成，然后返回结果值。可以在调用任何返回Promise的函数时使用<code>await</code>。</p>
</li>
</ul>
<p>我们通过一个例子来看下它与Promise的区别</p>
<p><strong>Promise</strong></p>
<pre><code class="language-javascript">fetch('coffee.jpg')
.then(response =&gt; response.blob())
.then(myBlob =&gt; {
  let objectURL = URL.createObjectURL(myBlob);
  let image = document.createElement('img');
  image.src = objectURL;
  document.body.appendChild(image);
})
.catch(e =&gt; {
  console.log('There has been a problem with your fetch operation: ' + e.message);
});
</code></pre>
<p><strong>async await</strong></p>
<pre><code class="language-javascript">async function myFetch() {
  try {
    let response = await fetch('coffee.jpg');
    let myBlob = await response.blob();

    let objectURL = URL.createObjectURL(myBlob);
    let image = document.createElement('img');
    image.src = objectURL;
    document.body.appendChild(image);
  } catch(e) {
    console.log(e);
  }
}

myFetch();
</code></pre>
<p>使用async、await会使你的代码看起来更像是同步代码，读起来也十分容易理解，因为他实际上就是在顺序执行，但是在等待await的时候并不会产生阻塞，影响其他渲染任务</p>
<h2><a class="header" href="#typescript" id="typescript">TypeScript</a></h2>
<blockquote>
<p>更加深入的学习可以参考<a href="https://www.typescriptlang.org/docs/home.html">官方文档</a>（<a href="https://www.tslang.cn/index.html">中文</a>），在这里我们做简单介绍</p>
</blockquote>
<p>JavaScript 是一个不具有强类型的动态语言，这赋予了它极大的灵活性，但也带来了开发和生产上可能存在的问题。TypeScript 是 JavaScript 的超集，使得 JavaScript 中的每一个变量和函数都具有和 C 一样的类型定义。你可以利用 TypeScript 在编译期进行类型检查，提前发现错误。我们在使用ts的时候，最终还是会将其编译为js代码，但是在编译的时候会进行静态类型检查如果发现有错误，编译的时候就会报错。</p>
<h3><a class="header" href="#类型注解" id="类型注解">类型注解</a></h3>
<p>TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。我们可以简单的使用<code>:</code>来添加类型注解，例如</p>
<pre><code class="language-typescript">function greeter(person: string) {
    return &quot;Hello, &quot; + person;
}
let user = [0, 1, 2];

greeter(user);
//greeter.ts(7,26): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.
</code></pre>
<p>在此展示最简单的基础类型</p>
<pre><code class="language-typescript">//布尔值
let isDone: boolean = false;

//数字
let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;

//字符串
let name: string = &quot;bob&quot;;
name = &quot;smith&quot;;
let sentence: string = `Hello, my name is ${ name }.`

//数组
let list: number[] = [1, 2, 3];
let list: Array&lt;number&gt; = [1, 2, 3];

//元组,表示一个已知元素数量和类型的数组，各元素的类型不必相同
// Declare a tuple type
let x: [string, number];
// Initialize it
x = ['hello', 10]; // OK
// Initialize it incorrectly
x = [10, 'hello']; // Error

//枚举
enum Color {Red, Green, Blue}
let c: Color = Color.Green;

//Void，表示一个函数没有返回值
function warnUser(): void {
    console.log(&quot;This is my warning message&quot;);
}

//Null 和 Undefined
let u: undefined = undefined;
let n: null = null;
//他们是所有类型的子类型
// 这样不会报错
let num: number = undefined;
</code></pre>
<p>这里单独说一下<code>any</code>，任意值（Any）用来表示允许赋值为任意类型，并且你可以对其访问任何属性，调用任何方法。它主要用于为那些在编程阶段还不清楚类型的变量指定一个类型，比如来自用户输入或第三方代码库的内容。如果你在声明变量的时候没有指定类型和初值，他会被识别为<code>any</code>类</p>
<pre><code class="language-typescript">let myFavoriteNumber: any = 'seven';
myFavoriteNumber = 7;

let something;
something = 'seven';
something = 7;
</code></pre>
<p>下面给出指定函数类型的例子</p>
<pre><code class="language-typescript">//完整
let myAdd: (x: number, y: number) =&gt; number =
    function(x: number, y: number): number { return x + y; };

//推断
// myAdd has the full function type
let myAdd = function(x: number, y: number): number { return x + y; };

// The parameters `x` and `y` have the type number
let myAdd: (baseValue: number, increment: number) =&gt; number =
    function(x, y) { return x + y; };
</code></pre>
<p>ts也可以设定可选参数以及参数默认值，可选参数在参数后加?即可</p>
<pre><code class="language-typescript">let myAdd = function(x: number = 1, y?: number): number { ...};
</code></pre>
<h3><a class="header" href="#类型断言" id="类型断言">类型断言</a></h3>
<p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。</p>
<p>类型断言的两种方式为</p>
<pre><code class="language-typescript">let someValue: any = &quot;this is a string&quot;;

let strLength1: number = (&lt;string&gt;someValue).length;

let strLength2: number = (someValue as string).length;
</code></pre>
<h3><a class="header" href="#联合类型" id="联合类型">联合类型</a></h3>
<p>联合类型（Union Types）表示取值可以为多种类型中的一种。联合类型使用 <code>|</code> 分隔每个类型。</p>
<pre><code class="language-typescript">let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;
</code></pre>
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong></p>
<pre><code class="language-typescript">function getLength(something: string | number): number {
    return something.length;
}

// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.
//   Property 'length' does not exist on type 'number'.
</code></pre>
<p>这时候我们就可以用到上面的类型断言</p>
<h3><a class="header" href="#类型别名" id="类型别名">类型别名</a></h3>
<p>我们使用 <code>type</code> 创建类型别名，类型别名常用于联合类型</p>
<pre><code class="language-ts">type Name = string;
type NameResolver = () =&gt; string;
type NameOrResolver = Name | NameResolver;
</code></pre>
<h3><a class="header" href="#a-hrefhttpswwwtslangcndocshandbookinterfaceshtml接口a" id="a-hrefhttpswwwtslangcndocshandbookinterfaceshtml接口a"><a href="https://www.tslang.cn/docs/handbook/interfaces.html">接口</a></a></h3>
<p>TypeScript的核心原则之一是对值所具有的<em>结构</em>进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。简单的说，在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p>
<pre><code class="language-typescript">interface Person {
    name: string;
    age: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25
};

let jack: Person = {
    name: 'Jack'
};
// index.ts(6,5): error TS2322: Type '{ name: string; }' is not assignable to type 'Person'.
//   Property 'age' is missing in type '{ name: string; }'.
</code></pre>
<p>当然也可以加入可选属性，上面的错误可以这样解决</p>
<pre><code class="language-typescript">interface Person {
    name: string;
    age?: number;
}
let jack: Person = {
    name: 'Jack'
};
</code></pre>
<h3><a class="header" href="#a-hrefhttpswwwtslangcndocshandbookgenericshtml泛型a" id="a-hrefhttpswwwtslangcndocshandbookgenericshtml泛型a"><a href="https://www.tslang.cn/docs/handbook/generics.html">泛型</a></a></h3>
<p>这个概念和C/C++里的模板比较相似，由于刚学过在此不作讲解，具体可以在读代码的时候学习</p>
<pre><code class="language-C++">template &lt;typename T&gt;
</code></pre>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;
</code></pre>
<p>EESAST前端代码中的一个例子</p>
<pre><code class="language-typescript">const columns: ColumnProps&lt;ITeam&gt;[] = [];
</code></pre>
<h3><a class="header" href="#a-hrefhttpswwwtslangcndocshandbookmoduleshtml模块a" id="a-hrefhttpswwwtslangcndocshandbookmoduleshtml模块a"><a href="https://www.tslang.cn/docs/handbook/modules.html">模块</a></a></h3>
<p>任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加<code>export</code>关键字来导出。</p>
<p>可以在声明的时候直接导出</p>
<pre><code class="language-typescript">export interface StringValidator {
    isAcceptable(s: string): boolean;
}

export const numberRegexp = /^[0-9]+$/;

export class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
</code></pre>
<p>也可以在声明之后的任意位置导出，并且可以重命名</p>
<pre><code class="language-typescript">class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
export { ZipCodeValidator };
export { ZipCodeValidator as mainValidator };
</code></pre>
<p>在导入的时候，可以直接导入，也可以进行重命名</p>
<pre><code class="language-typescript">import { ZipCodeValidator } from &quot;./ZipCodeValidator&quot;;

import { ZipCodeValidator as ZCV } from &quot;./ZipCodeValidator&quot;;
</code></pre>
<p>每个模块都可以有一个<code>default</code>导出。 默认导出使用 <code>default</code>关键字标记；并且一个模块只能够有一个<code>default</code>导出。对于<code>default</code>模块在导入的时候不必加大括号，而且可以直接重命名</p>
<pre><code class="language-typescript">//OneTwoThree.ts
export default &quot;123&quot;;
</code></pre>
<pre><code class="language-typescript">import num from &quot;./OneTwoThree&quot;;
</code></pre>
<h1><a class="header" href="#react--antd-入门教程" id="react--antd-入门教程">React + antd 入门教程</a></h1>
<blockquote>
<p>本节内容相关代码请访问<a href="https://github.com/duskmoon314/react-tutorial">react-tutorial</a>，<a href="https://duskmoon314.github.io/react-tutorial/chapter1/chapter_1.html">文档</a></p>
</blockquote>
<h2><a class="header" href="#说明" id="说明">说明</a></h2>
<p>本节将使用 Yarn 作为包管理，用 Node.js 运行一个 React App，结合 antd 组件从头开始搭建一个小游戏作为入门。会介绍以下内容：</p>
<ul>
<li>什么是 Node.js？如何使用 Yarn 进行包管理？</li>
<li>如何<strong>初始化</strong>一个使用 TypeScript 的 React 应用？</li>
<li>React 和 antd 分别是干什么的？</li>
<li>前端需要做些什么？</li>
</ul>
<blockquote>
<p>小游戏借鉴了<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html">Rust 文档</a>。对优质文档和启发灵感表示感谢。</p>
</blockquote>
<h2><a class="header" href="#相关依赖" id="相关依赖">相关依赖</a></h2>
<blockquote>
<p>本节内容的详细文档提供了使用 CodeSandbox 的在线环境与各阶段代码，如果读者自行配置环境遇到困难，可以尝试使用。出于一些原因，CodeSandbox 中的代码会与文档有些微的区别，但不涉及到本节说要讲解内容的重点。</p>
</blockquote>
<ul>
<li>Node.js 和 Yarn：请参阅<a href="https://duskmoon314.github.io/react-tutorial/chapter1/chapter_1.html">文档</a>进行安装</li>
<li>React</li>
<li>antd</li>
</ul>
<h1><a class="header" href="#linux-入门实操" id="linux-入门实操">Linux 入门实操</a></h1>
<blockquote>
<p>基本上是翻译了下<a href="https://missing.csail.mit.edu/2020">missing-semester</a>的 1、3 讲</p>
<p>写完这个发现 missing-semester 有<a href="https://missing-semester-cn.github.io/">中文版</a>orz</p>
</blockquote>
<h2><a class="header" href="#说明-1" id="说明-1">说明</a></h2>
<p>此处的文档为本次课程的 linux 实操部分，其他课件请见<a href="https://github.com/eesast/training2020/blob/master/basic_tool/linux-webserver">此处</a></p>
<h2><a class="header" href="#shell-基础" id="shell-基础">Shell 基础</a></h2>
<h3><a class="header" href="#shell-使用" id="shell-使用">shell 使用</a></h3>
<p>打开 shell 之后首先看到这样的提示符</p>
<pre><code class="language-shell">zxdclyz@Lyz:~$
</code></pre>
<p>用户名@设备名:当前路径，<code>~</code>代表 home 家路径</p>
<p>此时就可以输入命令了</p>
<pre><code class="language-shell">zxdclyz@Lyz:~$ date
Sat Jun 20 20:07:17 CST 2020
zxdclyz@Lyz:~$
</code></pre>
<p>通过输入 date 运行了 date 这个打印日期和时间的程序，然后提示符重新出现，告诉我们可以输入下一条命令</p>
<p>另一个十分基础的命令是 echo</p>
<pre><code class="language-shell">zxdclyz@Lyz:~$ echo hello world
hello world
</code></pre>
<p>echo 的作用是直接打印它的参数，在 shell 中，命令是以空格隔断的，第一个词指定运行的程序，后面的是参数，如果想要在一个参数中包括空格，可以使用<code>'</code>或者<code>&quot;</code>，也可以用<code>\(space)</code></p>
<pre><code class="language-shell">zxdclyz@Lyz:~$ echo 'hello world'
hello world
zxdclyz@Lyz:~$ echo hello\ world
hello world
</code></pre>
<p>不过在 echo 中看不出区别 orz</p>
<p>那么我们输入 date、echo 运行的是什么程序呢？shell 也是一个编程环境，类似 python，其中也有变量，如果输入了程序关键字之外的字段，shell 会去查找<code>$PATH</code>环境变量中的路径</p>
<pre><code class="language-shell">zxdclyz@Lyz:~$ echo $PATH
/usr/local/sbin:/usr/local/bin
</code></pre>
<p>其中的路径用<code>:</code>分隔，可以用<code>which</code>命令查看运行的程序所在路径</p>
<pre><code class="language-shell">zxdclyz@Lyz:~$ which echo
/bin/echo
</code></pre>
<p>如果程序所在路径不在环境变量里，也可以直接使用其完整路径来调用</p>
<pre><code class="language-shell">zxdclyz@Lyz:~$ /bin/echo eesast
eesast
</code></pre>
<h3><a class="header" href="#文件系统" id="文件系统">文件系统</a></h3>
<p>有关文件操作，<code>pwd</code>显示当前路径，<code>cd</code>改变路径，<code>ls</code>打印当前目录中的文件，<code>.</code>指当前目录，<code>..</code>指上级目录</p>
<pre><code class="language-shell">zxdclyz@Lyz:~/tutorial$ ls
a.txt  b.py  c.js
zxdclyz@Lyz:~/tutorial$ cd ../
zxdclyz@Lyz:~$ pwd
/home/zxdclyz
zxdclyz@Lyz:~$
</code></pre>
<p>使用<code>cd -</code>可以跳转到刚才所在的路径，用<code>mkdir</code>创建文件夹，<code>mv</code>移动文件，<code>cp</code>复制文件，<code>rm</code>删除文件，<code>touch</code>创建文件</p>
<p>有关文件权限，参考课件</p>
<h3><a class="header" href="#查看命令参数" id="查看命令参数">查看命令参数</a></h3>
<p>可以使用<code>man command</code>来进入手册页，也可以直接使用--help 参数查看</p>
<pre><code class="language-shell">zxdclyz@Lyz:/bin$ ls --help
...
zxdclyz@Lyz:/bin$ man ls
</code></pre>
<h3><a class="header" href="#连接程序" id="连接程序">连接程序</a></h3>
<p>在 shell 中，程序也有输入流和输出流，我们可以用<code>&gt; file</code>和<code>&lt; file</code>来重新引导流</p>
<pre><code class="language-shell">zxdclyz@Lyz:~/tutorial$ echo hello &gt; hello.txt
zxdclyz@Lyz:~/tutorial$ echo bye &gt;&gt; hello.txt
</code></pre>
<p>使用<code>&gt;&gt;</code>可以进行追加写</p>
<p>另一个十分有用的工具是 pipe<code>|</code>，它可以连接两个命令，将前一个命令的输出当做后一个命令的输入</p>
<pre><code class="language-shell">zxdclyz@Lyz:~/tutorial$ cat hello.txt
hello
bye
hello world
zxdclyz@Lyz:~/tutorial$ cat hello.txt|grep world
hello world
</code></pre>
<h2><a class="header" href="#vim-极简入门" id="vim-极简入门">Vim 极简入门</a></h2>
<p>如果你在使用服务器并且想简单地对一个文件进行编辑，使用 vim 是十分方便的（大量编辑我倾向于使用 VSCode 等远程连接），vim 本身拥有十分强大的功能，但我自己也并不会，所以只在此展示最基础的用法</p>
<p>使用<code>vim file</code>打开文件进行编辑</p>
<p>刚进入时处于正常模式，而 vim 中有这些模式</p>
<ul>
<li><strong>Normal</strong>: for moving around a file and making edits</li>
<li><strong>Insert</strong>: for inserting text</li>
<li><strong>Replace</strong>: for replacing text</li>
<li><strong>Visual</strong> (plain, line, or block): for selecting blocks of text</li>
<li><strong>Command-line</strong>: for running a command</li>
</ul>
<p>我们在此用到 insert 模式，在正常模式下按<code>i</code>进入 insert 模式，此时可以像其他编辑器一样对文件进行编辑，然后按<code>ESC</code>退回到正常模式</p>
<p>在正常模式下输入<code>:</code>会进入命令模式，最基础的命令有</p>
<ul>
<li><code>:q</code> quit (close window)</li>
<li><code>:w</code> save (“write”)</li>
<li><code>:wq</code> save and quit</li>
</ul>
<p>事实上 vim 还有许多十分强大的功能，感兴趣的同学可以自己了解</p>
<h2><a class="header" href="#tmux" id="tmux">tmux</a></h2>
<p>我们在使用 ssh 方法登录到服务器的时候是和服务器进行一次会话，而当我们从服务器断开的时候，会话结束，会话中的各个进程也会被终止，而 tmux 是用来解绑会话与打开的终端窗口的，可以让你启动的进程在断开连接之后继续运行</p>
<p>直接输入 tmux 命令会新建一个只有编号的 tmux 窗口，我们可以这样来新建命名的窗口</p>
<pre><code class="language-shell">$ tmux new -s &lt;session-name&gt;
</code></pre>
<p>在 tmux 窗口中，按下<code>Ctrl+b</code>，然后按<code>d</code>，可以从当前窗口分离，而窗口中的进程仍在后台运行</p>
<p>可以查看所有 tmux 会话</p>
<pre><code class="language-shell">$ tmux ls
# or
$ tmux list-session
</code></pre>
<p>然后使用<code>tmux attach</code>来重新接入会话</p>
<pre><code class="language-shell"># 使用会话编号
$ tmux attach -t 0

# 使用会话名称
$ tmux attach -t &lt;session-name&gt;
</code></pre>
<p>可以在会话中直接使用<code>Ctrl+d</code>或者输入<code>exit</code>来关闭，也可以在外部使用<code>tmux kill-session</code>命令杀死某个会话。</p>
<pre><code class="language-shell"># 使用会话编号
$ tmux kill-session -t 0

# 使用会话名称
$ tmux kill-session -t &lt;session-name&gt;
</code></pre>
<p>以上为 tmux 的最基础操作，更多可以参考<a href="http://www.ruanyifeng.com/blog/2019/10/tmux.html">这里</a></p>
<h1><a class="header" href="#docker" id="docker">Docker</a></h1>
<p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.org/">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 0.7 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a>。</p>
<img src="https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/media/docker-on-linux.png" width = "600" height = "400" alt="Docker 架构" align=center />
<p><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p>
<p>课件请见<a href="https://github.com/eesast/training2020/blob/master/basic_tool/docker">此处</a></p>
<h2><a class="header" href="#参考链接-1" id="参考链接-1">参考链接</a></h2>
<ul>
<li><a href="https://vuepress.mirror.docker-practice.com/">Docker — 从入门到实践</a></li>
<li><a href="https://docs.docker.com/">Docker官方文档</a></li>
</ul>
<h1><a class="header" href="#操作系统" id="操作系统">操作系统</a></h1>
<p>本讲主要介绍操作系统的相关知识，帮助大家快速建立操作系统的宏观认识。需要注意的是，操作系统涉及处理机管理、存储管理、文件系统、IO设备等多个方面，而本讲主要涉及处理机管理中的进程间通信、进程的同步与互斥、死锁等内容，较少涉及其它部分。以下为本讲大纲，详细课件参见<a href="https://github.com/eesast/training2020/blob/master/OS">仓库</a>。</p>
<h2><a class="header" href="#进程与线程" id="进程与线程">进程与线程</a></h2>
<h3><a class="header" href="#进程" id="进程">进程</a></h3>
<p>进程（Process）是具有独立功能的程序在某个数据集合上的一次运行活动，可以理解为操作系统执行的一个程序的实例。</p>
<p>三状态模型：运行、就绪、阻塞。</p>
<h3><a class="header" href="#线程" id="线程">线程</a></h3>
<p>线程（Thread）进一步减小了程序并发执行的时空开销，是轻量级进程。进程是资源分配的单位，线程是处理器调度的单位，同一个进程的多个线程共享资源。</p>
<p>用户级线程 vs 内核级线程</p>
<h3><a class="header" href="#处理器" id="处理器">处理器</a></h3>
<p>处理器状态：核心态（Kernel mode）与用户态（User mode），通过陷入（Trap）与修改程序状态字（PSW）互相切换。</p>
<p>CPU的一个核心上，同一时间片只能执行一个线程。操作系统在单核上实现并行的方式是通过处理器调度，使得各线程轮流执行，实现宏观并行。操作系统的调度需要陷入核心态，保存寄存器、堆栈，同时cache需要更新，因此有一定时间开销。</p>
<p>调度的时刻（抢先vs非抢先）：</p>
<ul>
<li>创建一个新进程后</li>
<li>一个进程运行完毕后</li>
<li>中断</li>
<li>一个进程被阻塞</li>
<li>时间片轮转</li>
</ul>
<p>对于计算密集型任务，频繁调度不划算；而对于IO密集型任务，调度是有较大收益的。</p>
<p>原语（primitive）：由若干条指令构成的 “原子操作（atomic operation）” 过程 ，作为一个整体而不可分割——要么全都完成 ，要么全都不做 要么全都不做 要么全都不做 。许多系统调用都是原语。原语可以避免因调度而被打断。</p>
<p>需要注意的是，C或其它编程语言的一条指令可能由多个汇编语句构成，而处理器执行汇编指令中都可能发生调度，因此同一条指令可能被打断，发生各种情况。</p>
<h3><a class="header" href="#linux--windows--posix-中的进程与线程" id="linux--windows--posix-中的进程与线程">Linux / Windows / POSIX 中的进程与线程</a></h3>
<p>Linux无线程概念，但可共享资源的进程可看作线程，相当于内核级线程。</p>
<p>Windows进程是惰性的，无实际作用，线程是调度单位，内核级线程。</p>
<p>POSIX未限定用户级/内核级线程。多线程编程接口标准pthread。</p>
<h2><a class="header" href="#进程同步与互斥" id="进程同步与互斥">进程同步与互斥</a></h2>
<ul>
<li>
<p>禁止中断</p>
<p>进入临界区前执行关闭中断指令，离开临界区后执行开中断。</p>
<p>简单但可靠性差，不适合多处理器。</p>
</li>
<li>
<p>严格轮转法
进程严格轮流进入临界区。
忙等待，效率较低，且可能在临界区外阻塞别的进程。</p>
</li>
<li>
<p>Petersen算法
可以正常工作的解决互斥问题的算法，仍使用锁。
忙等待，效率较低。</p>
</li>
<li>
<p>硬件指令方法
使用硬件提供不被打断的单条指令读写共享变量。
适用于任意数目进程，且较简单，但仍有忙等待。</p>
</li>
<li>
<p>信号量
使用原语访问信号量管理资源。
不必忙等，效率较高，但信号量的控制分布在整个程序中，正确性难以保证。</p>
</li>
<li>
<p>管程
信号量及其操作的高级语言封装。
效率同信号量一样，易于管理开发。</p>
</li>
<li>
<p>消息传递
用以实现分布式系统的同步、互斥。
支持分布式系统，但消息传递本身效率较低且不完全可靠。</p>
</li>
</ul>
<p>忙等待不但浪费CPU时间，还会出现优先级反转问题（priority inversion problem）。</p>
<h2><a class="header" href="#进程间通信" id="进程间通信">进程间通信</a></h2>
<h3><a class="header" href="#linux进程间通信" id="linux进程间通信">Linux进程间通信</a></h3>
<ul>
<li>信号</li>
<li>管道</li>
<li>消息队列</li>
<li>共享内存</li>
<li>套接字</li>
</ul>
<h3><a class="header" href="#windows进程间通信" id="windows进程间通信">Windows进程间通信</a></h3>
<ul>
<li>管道</li>
<li>共享内存</li>
<li>邮件槽</li>
<li>套接字</li>
</ul>
<h2><a class="header" href="#经典ipc问题" id="经典ipc问题">经典IPC问题</a></h2>
<ul>
<li>生产者-消费者问题</li>
<li>读者-写者问题</li>
<li>睡眠理发师问题</li>
<li>哲学家进餐问题</li>
</ul>
<h2><a class="header" href="#死锁" id="死锁">死锁</a></h2>
<p>死锁（Deadlock）是指系统中多个进程无限制地等待永远不会发生的条件。</p>
<p>死锁发生的必要条件：</p>
<ul>
<li>互斥</li>
<li>请求和保持</li>
<li>非剥夺</li>
<li>环路等待</li>
</ul>
<p>处理死锁问题的四种方法：</p>
<ul>
<li>鸵鸟算法</li>
<li>死锁预防
<ul>
<li>预先静态分配法</li>
<li>有序资源使用法</li>
</ul>
</li>
<li>死锁检测
<ul>
<li>资源分配图算法</li>
</ul>
</li>
<li>死锁避免
<ul>
<li>银行家算法</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
