<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>EESAST Training 2020</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="git/git.html"><strong aria-hidden="true">2.</strong> Git</a></li><li class="chapter-item expanded "><a href="web/web.html"><strong aria-hidden="true">3.</strong> Web</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="web/html&css.html"><strong aria-hidden="true">3.1.</strong> HTML&amp;CSS</a></li><li class="chapter-item expanded "><a href="web/js&ts.html"><strong aria-hidden="true">3.2.</strong> JS&amp;TS</a></li><li class="chapter-item expanded "><a href="web/react.html"><strong aria-hidden="true">3.3.</strong> React + antd 入门</a></li><li class="chapter-item expanded "><a href="web/backend.html"><strong aria-hidden="true">3.4.</strong> 后端技术栈入门（Node.js + Express + MongoDB</a></li><li class="chapter-item expanded "><a href="web/GraphQL.html"><strong aria-hidden="true">3.5.</strong> GraphQL, Hasura, Apollo</a></li></ol></li><li class="chapter-item expanded "><a href="linux-webserver/linux.html"><strong aria-hidden="true">4.</strong> Linux</a></li><li class="chapter-item expanded "><a href="docker/docker.html"><strong aria-hidden="true">5.</strong> Docker</a></li><li class="chapter-item expanded "><a href="OS/OS.html"><strong aria-hidden="true">6.</strong> 操作系统</a></li><li class="chapter-item expanded "><a href="CSharp/CS-Learning1-Basic.html"><strong aria-hidden="true">7.</strong> CSharp1</a></li><li class="chapter-item expanded "><a href="CSharp/CS-Learning2-MultiThread.html"><strong aria-hidden="true">8.</strong> CSharp2</a></li><li class="chapter-item expanded "><a href="unity/unity.html"><strong aria-hidden="true">9.</strong> Unity</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">EESAST Training 2020</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/eesast/training2020" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>本文档为清华电子系学生科协 2020 年暑期培训<a href="https://github.com/eesast/training2020">仓库</a>中各部分内容介绍及相关依赖的简要安装说明。</p>
<p>培训所用的文档、教学用 PPT 及相关仓库与依赖链接基本上可以在仓库中找到。</p>
<blockquote>
<p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">EESAST Training 2020</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/eesast/training2020" property="cc:attributionName" rel="cc:attributionURL">EESAST</a> 采用 <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享 署名-相同方式共享 4.0 国际 许可协议</a>进行许可。
多数内容将以 CC-BY-SA 4.0 进行许可，部分培训内容的作者可能会有特殊许可，若有需要还请注意。</p>
</blockquote>
<p>培训内容主要分为三个大部分：</p>
<ul>
<li>基础工具 Git, Docker</li>
<li>队式开发技术栈</li>
<li>网站开发技术栈</li>
</ul>
<p>具体内容还请参阅各章说明</p>
<h1><a class="header" href="#git" id="git">Git</a></h1>
<p>Git 是一个分布式版本管理系统，虽然设计上可能存在一些问题，但不妨碍其成为如今使用最广的地位。软件部的开发采取 Git 进行版本管理，也推荐大家将 Git 应用到各种需要版本管理的地方。</p>
<p><a href="git/../../../basic%20tool/git.pptx">课件</a></p>
<h2><a class="header" href="#参考链接" id="参考链接">参考链接</a></h2>
<ul>
<li><a href="https://github.com/pcottle/learnGitBranching">pcottle/learnGitBranching</a></li>
<li><a href="https://github.com/k88hudson/git-flight-rules">k88hudson/git-flight-rules</a></li>
</ul>
<h1><a class="header" href="#web" id="web">web</a></h1>
<p>这一章将基于 EESAST 目前网站方面使用的技术进行培训，内容主要为以下几个部分：</p>
<ul>
<li>Html, CSS, JavaScript/TypeScript 基础</li>
<li>Node.js 与包管理</li>
<li>React + antd</li>
<li>Restful API 与 Express</li>
<li>GraphQL + Hasura + Apollo</li>
<li>数据库 MongoDB 和 PostgreSQL</li>
<li>Web测试 Mocha + Chai</li>
<li>CI/CD</li>
</ul>
<p>具体内容安排请参照各小节说明</p>
<p>需要用到的工具及相关链接如下：</p>
<ul>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a></li>
<li>Node.js
<ul>
<li><a href="https://nodejs.org/en/download/">官方网站</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/nodejs-release/">清华 tuna 镜像</a>
<ul>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/nodejs-release/">tuna 镜像帮助页面</a></li>
</ul>
</li>
<li><a href="https://mirrors.bfsu.edu.cn/nodejs-release/">北京外国语大学镜像</a>
<ul>
<li><a href="https://mirrors.bfsu.edu.cn/help/nodejs-release/">北外镜像帮助页面</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://yarn.bootcss.com/docs/getting-started/">Yarn</a></li>
<li><a href="https://react.docschina.org/">React</a></li>
<li><a href="https://ant.design/index-cn">Ant Design</a></li>
<li><a href="https://www.expressjs.com.cn/">Express</a></li>
<li><a href="https://graphql.org/">GraphQL</a></li>
<li><a href="https://hasura.io/">Hasura</a></li>
<li><a href="https://www.apollographql.com/">Apollo</a></li>
<li><a href="https://www.mongodb.com/">MongoDB</a></li>
<li><a href="https://www.postgresql.org/">PostgreSQL</a></li>
<li><a href="https://mochajs.org/">Mocha</a></li>
<li><a href="https://www.chaijs.com/">Chai</a></li>
<li><a href="https://help.github.com/en/actions">GitHub Actions</a></li>
</ul>
<h1><a class="header" href="#htmlcss-入门" id="htmlcss-入门">HTML&amp;CSS 入门</a></h1>
<blockquote>
<p>这里介绍的知识非常基础，因为网站组的同学们在后面写网站的时候很少直接写 HTML&amp;CSS（尤其是 HTML），这里讲只是为了让大家简单了解下网页的机制</p>
</blockquote>
<blockquote>
<p>本文档参考<a href="https://developer.mozilla.org/zh-CN/">MDN</a>完成，希望深入学习的同学可以参考</p>
</blockquote>
<h2><a class="header" href="#html" id="html">HTML</a></h2>
<blockquote>
<p>参考：https://developer.mozilla.org/zh-CN/docs/Web/HTML</p>
</blockquote>
<h3><a class="header" href="#基础" id="基础">基础</a></h3>
<p>HTML (Hyper Text Markup Language) 不是一门编程语言，而是一种用来告知浏览器如何组织页面的标记语言。HTML 可复杂、可简单，一切取决于开发者。它由一系列的元素（elements）组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。 一对标签（ tags）可以为一段文字或者一张图片添加超链接，将文字设置为斜体，改变字号，等等。</p>
<p>最简单的一个内容是这样的</p>
<p>欢迎大家加入科协</p>
<pre><code class="language-html">&lt;p&gt;欢迎大家加入科协&lt;/p&gt;
</code></pre>
<p>这是一个段落(p)元素，一个 html 元素的组成分为</p>
<ol>
<li><strong>开始标签</strong>（Opening tag）：包含元素的名称，被左、右角括号所包围。表示元素从这里开始或者开始起作用</li>
<li><strong>结束标签</strong>（Closing tag）：与开始标签相似，只是其在元素名之前包含了一个斜杠。这表示着元素的结尾 —— 在本例中即段落在此结束。初学者常常会犯忘记包含结束标签的错误，这可能会产生一些奇怪的结果。</li>
<li><strong>内容</strong>（Content）：元素的内容，本例中就是所输入的文本本身。</li>
<li><strong>元素</strong>（Element）：开始标签、结束标签与内容相结合，便是一个完整的元素。</li>
</ol>
<p>HTML 元素可以进行嵌套，比如</p>
<p><em>欢迎</em>大家加入<strong>科协</strong></p>
<pre><code class="language-html">&lt;p&gt;&lt;em&gt;欢迎&lt;/em&gt;大家加入&lt;strong&gt;科协&lt;/strong&gt;&lt;/p&gt;
</code></pre>
<h3><a class="header" href="#块级元素和内联元素" id="块级元素和内联元素">块级元素和内联元素</a></h3>
<p>块级元素在页面中以块的形式展现 —— 相对于其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现，例如上面的<code>&lt;p&gt;</code></p>
<p>内联元素通常出现在块级元素中并环绕文档内容的一小部分，而不是一整个段落或者一组内容。内联元素不会导致文本换行：它通常出现在一堆文字之间例如超链接元素<code>&lt;a&gt;</code>或者强调元素<code>&lt;em&gt;</code>和<code>&lt;strong&gt;</code>。</p>
<h3><a class="header" href="#空元素" id="空元素">空元素</a></h3>
<p>不是所有元素都拥有开始标签，内容，结束标签，一些元素只有一个标签，通常用来在此元素所在位置插入/嵌入一些东西，比如<code>&lt;img&gt;</code></p>
<h3><a class="header" href="#属性" id="属性">属性</a></h3>
<p>使用属性来给元素设定额外信息，属性的基本写法为</p>
<pre><code class="language-html">&lt;p class=&quot;foobar&quot;&gt;EESAST&lt;/p&gt;
</code></pre>
<p>用空格与元素名或前一个属性隔开，<code>属性名=&quot;值&quot;</code>（单引号双引号都可）</p>
<p>比较典型的例子就是元素<code>&lt;a&gt;</code>，用来创建链接</p>
<p><a href="https://eesast.com" title="科协官网">EESAST</a></p>
<pre><code class="language-html">&lt;a href=&quot;https://eesast.com&quot; title=&quot;科协官网&quot;&gt;EESAST&lt;/a&gt;
</code></pre>
<h3><a class="header" href="#一个-html-文件的结构" id="一个-html-文件的结构">一个 HTML 文件的结构</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;我的测试站点&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;这是我的页面&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><code>&lt;!DOCTYPE html&gt;</code>: 声明文档类型</li>
<li><code>&lt;html&gt;&lt;/html&gt;</code>: <code>&lt;html&gt;</code>元素。这个元素包裹了整个完整的页面，是一个根元素。</li>
<li><code>&lt;head&gt;&lt;/head&gt;</code>: <code>&lt;head&gt;</code>元素.</li>
<li><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>: 元数据，在这里是设置文档使用 utf-8 字符集编码，也可以像<code>&lt;meta name=&quot;author&quot; content=&quot;Chris Mills&quot;&gt;</code>这样用 name 和 content 来设置其他信息，当然在不同的应用场景可以设置很多不同的元数据</li>
<li><code>&lt;title&gt;&lt;/title&gt;</code>: 设置页面标题</li>
<li><code>&lt;body&gt;&lt;/body&gt;</code>: <code>&lt;body&gt;</code>元素， 包含了你访问页面时所有显示在页面上的内容</li>
</ul>
<h3><a class="header" href="#在-html-中应用-css-和-javascript" id="在-html-中应用-css-和-javascript">在 HTML 中应用 CSS 和 JavaScript</a></h3>
<p>对于 CSS，需要加入一个<code>&lt;link&gt;</code>元素，rel=&quot;stylesheet&quot;表明这是文档的样式表，而 href 包含了样式表文件的路径，这个元素一般放在<code>&lt;head&gt;</code>里</p>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;my-css-file.css&quot; /&gt;
</code></pre>
<p>对于 js 脚本，加入<code>&lt;script&gt;</code>元素，src 为脚本的路径。<code>&lt;script&gt;</code>部分没必要非要放在文档头部，实际上，把它放在文档的尾部<code>&lt;/body&gt;</code>标签之前是一个更好的选择，这样可以确保在加载脚本之前浏览器已经解析了 HTML 内容</p>
<pre><code class="language-html">&lt;script src=&quot;my-js-file.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>这里 script 元素没有内容，但他不是一个空元素，你也可以直接把脚本写在元素里</p>
<h3><a class="header" href="#html-的基本布局" id="html-的基本布局">HTML 的基本布局</a></h3>
<ul>
<li><code>&lt;header&gt;</code>：页眉。</li>
<li><code>&lt;nav&gt;</code>：导航栏。</li>
<li><code>&lt;main&gt;</code>：主内容。主内容中还可以有各种子内容区段，可用<code>&lt;article&gt;</code>、<code>&lt;section&gt;</code> 和<code>&lt;div&gt;</code>等元素表示。</li>
<li><code>&lt;aside&gt;</code>：侧边栏，经常嵌套在<code>&lt;main&gt;</code>中。</li>
<li><code>&lt;footer&gt;</code>：页脚。</li>
</ul>
<p>关于完整的 html 元素和属性，可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference">这里</a></p>
<h2><a class="header" href="#css" id="css">CSS</a></h2>
<blockquote>
<p>参考：https://developer.mozilla.org/zh-CN/docs/Web/CSS</p>
</blockquote>
<h3><a class="header" href="#基础-1" id="基础-1">基础</a></h3>
<p>CSS 是一门基于规则的语言，他的基础结构为：由一个选择器开头，后接一对大括号，在大括号内部定义一个或多个形式为 <code>属性(property):值(value);</code> 的声明(declarations)。每个声明都指定了我们所选择元素的一个属性，之后跟一个我们想赋给这个属性的值。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference">这里</a>可以查看所有属性。</p>
<pre><code class="language-css">h1 {
  color: red;
  font-size: 5em;
}

p {
  color: black;
}
</code></pre>
<h4><a class="header" href="#元素选择器" id="元素选择器">元素选择器</a></h4>
<p>使用元素选择器来直接匹配一种 html 元素</p>
<pre><code class="language-css">p {
  color: green;
}
</code></pre>
<p>不同的选择器可以用<code>,</code>隔开来使用多个选择器</p>
<pre><code class="language-html">p, li { color: green; }
</code></pre>
<p>这种直接指定元素类型的写法只能同时应用于所有同类元素，在实际使用的时候是十分不方便的，因此我们还可以使用类名来进一步指定作用的对象。前面说到 HTML 中的元素可以添加属性，这里的类名选择器就对应标签中的<code>class</code>属性，比如</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;项目一&lt;/li&gt;
  &lt;li class=&quot;special&quot;&gt;项目二&lt;/li&gt;
  &lt;li&gt;项目 &lt;em&gt;三&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<pre><code class="language-css">.special {
  color: orange;
  font-weight: bold;
}
</code></pre>
<p>这里指定了属于 special 类的元素进行设置，在在选择器的开头加<code>.</code>即为指定类，当然可以同时指定元素和类</p>
<pre><code class="language-css">li.special,
span.special {
  color: orange;
  font-weight: bold;
}
</code></pre>
<p>此外，我们还可以根据元素的位置来进行选择，在选择器中使用<code>空格</code>来表示包含（嵌套）关系，用<code>+</code>来表示相邻关系，例如</p>
<pre><code class="language-css">li em {
  color: rebeccapurple;
}
</code></pre>
<p>表示选择嵌套在<code>&lt;li&gt;</code>内部的<code>&lt;em&gt;</code></p>
<pre><code class="language-css">h1 + p {
  font-size: 200%;
}
</code></pre>
<p>表示选择跟在<code>&lt;h1&gt;</code>后面的<code>&lt;p&gt;</code></p>
<p>可以尝试下解读这个选择器</p>
<pre><code class="language-css">body h1 + p .special {
  color: yellow;
  background-color: black;
  padding: 5px;
}
</code></pre>
<h3><a class="header" href="#盒模型" id="盒模型">盒模型</a></h3>
<blockquote>
<p>参考：https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model</p>
</blockquote>
<p>在 CSS 中，所有的元素都被一个个的“盒子（box）”包围着，理解这些“盒子”的基本原理，可以帮助我们使用 CSS 实现准确布局、处理元素排列。</p>
<p>CSS 中组成一个块级盒子需要:</p>
<ul>
<li><strong>Content box</strong>: 这个区域是用来显示内容，大小可以通过设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"><code>height</code></a>.</li>
<li><strong>Padding box</strong>: 包围在内容区域外部的空白区域； 大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding"><code>padding</code></a> 相关属性设置。</li>
<li><strong>Border box</strong>: 边框盒包裹内容和内边距。大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border"><code>border</code></a> 相关属性设置。</li>
<li><strong>Margin box</strong>: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a> 相关属性设置。</li>
</ul>
<p>如下图：</p>
<p><img src="web/./images/box-model.png" alt="box" /></p>
<p>在标准模型中，如果你给盒设置 <code>width</code> 和 <code>height</code>，实际设置的是 <em>content box</em>。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小</p>
<pre><code class="language-css">.box {
  width: 350px;
  height: 150px;
  margin: 25px;
  padding: 25px;
  border: 5px solid black;
}
</code></pre>
<p>可以尝试计算一下这个盒子的大小</p>
<h1><a class="header" href="#javascripttypescript" id="javascripttypescript">JavaScript&amp;TypeScript</a></h1>
<h2><a class="header" href="#javascript" id="javascript">JavaScript</a></h2>
<blockquote>
<p>参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript</p>
<p>更详细的JavaScript学习资料：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</p>
</blockquote>
<h3><a class="header" href="#什么是javascript" id="什么是javascript">什么是JavaScript</a></h3>
<p>JavaScript 是一门跨平台、面向对象的脚本语言，它能使网页可交互(尽管我们这里不会介绍这部分内容)。 JavaScript 堪称世界上被人误解最深的编程语言，虽然常被嘲为“玩具语言”，但在它看似简洁的外衣下，还隐藏着强大的语言特性。 JavaScript 目前广泛应用于众多知名应用中，对于网页和移动开发者来说，深入理解 JavaScript 就尤为必要。</p>
<p>与大多数编程语言不同，JavaScript 没有输入或输出的概念。它是一个在宿主环境（host environment）下运行的脚本语言，任何与外界沟通的机制都是由宿主环境提供的。浏览器是最常见的宿主环境，但在非常多的其他程序中也包含 JavaScript 解释器，如 Adobe Acrobat、Adobe Photoshop、SVG 图像、Yahoo! 的 Widget 引擎，<strong>Node.js</strong>之类的服务器端环境。</p>
<p>我们有时候也会看到ECMAScript或者ES6之类的称呼，ECMA是JavaScript 的标准化组织，ECMAScript是针对 JavaScript 语言制定的标准，之所以不叫 JavaScript，是因为Java和JavaScript的商标都被注册了。因此ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）</p>
<h3><a class="header" href="#javascript基础语法" id="javascript基础语法">JavaScript基础语法</a></h3>
<p>JavaScript 是一种多范式的动态语言，它包含类型、运算符、标准内置（ built-in）对象和方法。在基本语法方面，JavaScript有很多和C/C++相似的地方。JavaScript同样支持函数式编程——<strong>因为它们也是对象，函数也可以被保存在变量中，并且像其他对象一样被传递</strong>。</p>
<h4><a class="header" href="#数据类型" id="数据类型">数据类型</a></h4>
<p>JavaScript 中的类型如下</p>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number"><code>Number</code></a>（数字）</p>
<ul>
<li>3/2=1.5</li>
<li>特殊的值 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a>（Not a Number 的缩写），如果把 <code>NaN</code> 作为参数进行任何数学运算，结果也会是 <code>NaN</code>。<code>NaN</code>如果通过 <code>==</code> 、 <code>!=</code> 、 <code>===</code> 、以及 <code>!==</code>与其他任何值比较都将不相等 -- 包括与其他 NAN值进行比较。必须使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN"><code>Number.isNaN()</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN"><code>isNaN()</code></a> 函数</li>
<li>内置对象 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math"><code>Math</code></a>支持一些高级的计算；</li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a>（字符串）</p>
<ul>
<li>
<p>JavaScript 中的字符串是一串Unicode 字符序列</p>
</li>
<li>
<p><code>'</code>和<code>&quot;</code>皆可</p>
</li>
<li>
<p>可以使用内置函数 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt"><code>parseInt()</code></a>和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseFloat"><code>parseFloat()</code></a>来将字符串转为number</p>
</li>
<li>
<p>可以在字符串字面值上使用字符串对象的所有方法——JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串对象，比如<code>'eesast'.length</code></p>
</li>
<li>
<p>在ES2015中，引入了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings">模板字符串</a>，使用反引号 (` `) 来代替普通字符串中的用双引号和单引号，我们对其最常见的使用就是使用占位符<code>${expression}</code>来在其中插入表达式，例如</p>
<pre><code class="language-javascript">let name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello ${name}, how are you ${time}?`

let a = 5;
let b = 10;
console.log(`Fifteen is ${a + b} and
not ${2 * a + b}.`);
</code></pre>
</li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><code>Boolean</code></a>（布尔）</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a>（符号）（ES2015 新增）</p>
</li>
<li>
<p><code>Object</code></p>
<p>（对象）</p>
<ul>
<li>
<p><code>Function</code>（函数）</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a>（数组）</p>
<ul>
<li>
<p>JavaScript 数组的长度和元素类型都是非固定的，并且其数据在内存中也可以不连续</p>
</li>
<li>
<p>和上面的String类似，可以<code>new Array()</code>来创建数组，当然更简单的是使用字面量来创建<code>let a =['abc',1]; </code>，同样地可以直接对这样创建的数组使用Array对象的方法，例如<code>a.pop();</code></p>
</li>
<li>
<pre><code class="language-javascript">let a = [1, 2, , 4];
console.log(a[2]);
//undefined
a[100]=100;
console.log(a.length);
//101
</code></pre>
</li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Date"><code>Date</code></a>（日期）</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp"><code>RegExp</code></a>（正则表达式）</p>
</li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>（空）</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>（未定义）</p>
</li>
</ul>
<p>可以看到函数和数组也属于对象</p>
<h4><a class="header" href="#注释" id="注释">注释</a></h4>
<p>JavaScript 注释的语法和 C++ 或许多其他语言类似</p>
<pre><code class="language-javascript">// 单行注释

/* 这是一个更长的,
   多行注释
*/
</code></pre>
<h4><a class="header" href="#变量" id="变量">变量</a></h4>
<p>JavaScript有三种声明变量的方式。</p>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var"><code>var</code></a></p>
<p>声明一个变量，可选初始化一个值。</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a></p>
<p>声明一个块作用域的局部变量，可选初始化一个值。</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const"><code>const</code></a></p>
<p>声明一个块作用域的只读常量，必须初始化一个值。</p>
</li>
</ul>
<p>如果声明了一个变量却没有对其赋值，那么这个变量的类型就是 <code>undefined</code></p>
<p><code>const</code>很明显是一个常量，他是只读的，而<code>let</code>与<code>var</code>的主要区别在于，<code>let</code>的作用域是块作用域，而<code>var</code>的作用域是全局或者函数作用域(<code>const</code>也是块作用域)，并且<code>let</code>没有变量提升</p>
<p>最简单的例子如下</p>
<pre><code class="language-javascript">{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1

</code></pre>
<p>有关变量提升，指的是</p>
<pre><code class="language-javascript">// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre>
<p>他们的详细区别可见<a href="https://es6.ruanyifeng.com/#docs/let">此处</a></p>
<h4><a class="header" href="#运算符" id="运算符">运算符</a></h4>
<p>这里只介绍与C++不同的部分</p>
<ul>
<li>
<p>求幂：<code>x**2</code></p>
</li>
<li>
<p>全等和不全等：<code>x===y</code> <code>x!==y</code>比较两个操作数是否相等且类型相同</p>
</li>
<li>
<p>一元的正：即<code>+</code>，如果操作数在之前不是number，试图将其转换为number</p>
</li>
<li>
<p>字符串运算：<code>+</code>可以直接连接两个字符串，并同时会尝试将另一个操作数转换为string</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值</a>：将属性/值从对象/数组中取出,赋值给其他变量，例如</p>
<pre><code class="language-javascript">var a, b, rest;
[a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(a); // 10
console.log(b); // 20
console.log(rest); // [30, 40, 50]

var o = {p: 42, q: true};
var {p, q} = o;
</code></pre>
</li>
</ul>
<h4><a class="header" href="#控制结构" id="控制结构">控制结构</a></h4>
<p>JavaScript 的控制结构与其他类 C 语言类似，在此进行一下罗列</p>
<pre><code class="language-javascript">var name = &quot;kittens&quot;;
if (name == &quot;puppies&quot;) {
  name += &quot;!&quot;;
} else if (name == &quot;kittens&quot;) {
  name += &quot;!!&quot;;
} else {
  name = &quot;!&quot; + name;
}
name == &quot;kittens!!&quot;; // true

//--------------------------------------
while (true) {
  // 一个无限循环！
}

var input;
do {
  input = get_input();
} while (inputIsNotValid(input))
//---------------------------------------
for (var i = 0; i &lt; 5; i++) {
  // 将会执行五次
}

//---------------------------------------
switch(action) {
    case 'draw':
        drawIt();
        break;
    case 'eat':
        eatIt();
        break;
    default:
        doNothing();
}
</code></pre>
<p>JavaScript 也还包括其他两种重要的 for 循环： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of"><code>for</code>...<code>of</code></a></p>
<pre><code class="language-js">for (let value of array) {
  // do something with value
}
</code></pre>
<p>和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for</code>...<code>in</code></a> ：</p>
<pre><code class="language-js">for (let property in object) {
  // do something with object property
}
</code></pre>
<p><code>for ... in</code>是为遍历对象属性而构建的，不建议与数组一起使用</p>
<h4><a class="header" href="#对象" id="对象">对象</a></h4>
<p>JavaScript 中的对象，Object，可以简单理解成“名称-值”对，与我们知道的Python 中的字典（Dictionary）、C/C++ 中的散列表（Hash table）比较相似</p>
<p>有两种简单方法可以创建一个空对象：</p>
<pre><code class="language-js">var obj = new Object();
</code></pre>
<p>和：</p>
<pre><code class="language-js">var obj = {};
</code></pre>
<p>这两种方法在语义上是相同的。第二种更方便的方法叫作“对象字面量（object literal）”法。这种也是 JSON 格式的核心语法，一般我们优先选择第二种方法。</p>
<p>有关对象的访问和成员设置</p>
<pre><code class="language-javascript">person.age = 45
person['name']['last'] = 'Cratchit'
</code></pre>
<p>和大家刚学过的C++类似，这里的对象也有<code>this</code>来指向了当前代码运行时的对象</p>
<p>有关OOP的细节在这里不再介绍，其概念与C++有一些相似性，如果想复习一下OOP并且了解Js中的对象可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects">这里</a></p>
<h4><a class="header" href="#函数" id="函数">函数</a></h4>
<p>最简单的函数定义十分简单</p>
<pre><code class="language-javascript">function add(x, y) {
    var total = x + y;
    return total;
}
</code></pre>
<p>如果调用函数时没有提供足够的参数，缺少的参数会被 <code>undefined</code> 替代，而事实上你传入的参数在一个名为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments"><code>arguments</code></a> 的函数内部对象中，可以像数组一样来访问它，所以你传入了过多的参数也是可以的</p>
<pre><code class="language-javascript">function add() {
    var sum = 0;
    for (var i = 0, j = arguments.length; i &lt; j; i++) {
        sum += arguments[i];
    }
    return sum;
}

add(2, 3, 4, 5); // 14
</code></pre>
<p><code>arguments</code>写起来又丑又长，我们可以用剩余参数来实现相似的功能。剩余参数操作符在函数中以：<strong>...variable</strong> 的形式被使用，它将包含在调用函数时使用的未捕获整个参数列表到这个变量中，例如</p>
<pre><code class="language-javascript">function avg(first, ...args) {
  var sum = first;
  for (let value of args) {
    sum += value;
  }
  return sum / args.length;
}

avg(2, 3, 4, 5); // 3.5
</code></pre>
<blockquote>
<p>和剩余参数操作符长得一样的一个语法是展开语法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">展开语法(Spread syntax)</a>, 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。例如</p>
<pre><code class="language-javascript">let a = [1,2,3];
let b = {1:&quot;1&quot;,2:&quot;2&quot;}

let c = [...a, 4];
//[1, 2, 3, 4]
let d ={...b,3:&quot;3&quot;};
//{1: &quot;1&quot;, 2: &quot;2&quot;, 3: &quot;3&quot;}
</code></pre>
<p>可以看到这种语法在利用已有的数组/对象构造新的数组/对象时十分方便</p>
</blockquote>
<p>JavaScript 也允许在一个函数内部定义函数，它们可以访问父函数作用域中的变量</p>
<pre><code class="language-javascript">function parentFunc() {
  var a = 1;

  function nestedFunc() {
    var b = 4; // parentFunc 无法访问 b
    return a + b;
  }
  return nestedFunc(); // 5
}
</code></pre>
<p>JavaScript 允许创建匿名函数，可以通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>来实现，函数表达式也可以被赋值给一个变量，例如</p>
<pre><code class="language-javascript">//直接调用
(function(x, y){
    return x + y;
})(1,2);
//3

//作为参数传递
setTimeout(function(){console.log('111');},1000);

//赋值给变量
const add = function(x, y){
    return x + y;
}
add(1,2);
//3
</code></pre>
<p>而除了函数表达式之外，我们还有一种更加简洁的方式来创建函数--<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a></p>
<p>引入箭头函数有两个方面的作用：更简短的函数并且不绑定<code>this</code></p>
<p>箭头函数的基本语法为</p>
<pre><code class="language-javascript">(param1, param2, …, paramN) =&gt; { statements } 

(param1, param2, …, paramN) =&gt; expression
//相当于：(param1, param2, …, paramN) =&gt;{ return expression; }

// 当只有一个参数时，圆括号是可选的：
(singleParam) =&gt; { statements }
singleParam =&gt; { statements }

// 没有参数的函数应该写成一对圆括号。
() =&gt; { statements }
</code></pre>
<p>在使用匿名函数的地方箭头函数是十分常见的，箭头函数没有单独的<code>this</code>，不绑定<code>arguments</code>，不能用作构造函数，不太适合作为方法</p>
<h3><a class="header" href="#异步" id="异步">异步</a></h3>
<h4><a class="header" href="#异步基本概念" id="异步基本概念">异步基本概念</a></h4>
<p>通常来说，程序都是顺序执行，同一时刻只会发生一件事。如果一个函数依赖于另一个函数的结果，它只能等待那个函数结束才能继续执行。这是令人沮丧的体验，没有充分利用计算机的计算能力 — 尤其是在计算机普遍都有多核CPU的时代，坐在那里等待毫无意义，你完全可以在另一个处理器内核上干其他的工作，同时计算机完成耗时任务的时候通知你。这样你可以同时完成其他工作，这就是<strong>异步编程</strong>的出发点。</p>
<p>具体来说，我们在web编程中，当浏览器里面的一个web应用进行密集运算还没有把控制权返回给浏览器的时候，整个浏览器就像冻僵了一样，即出现了<strong>阻塞</strong>。在实际应用中，这种情况可能是因为向后端请求数据，然后对得到的数据进行处理并展示，在等待数据的时候，就会发生阻塞。而会发生阻塞是因为JavaScript传统上是单线程的，即每个任务顺序执行，只有前面的结束了，后面的才能开始。</p>
<pre><code>Main thread: Task A                   Task B
    Promise:      |__async operation__|
</code></pre>
<p>如上，在异步中，任务B会在任务A执行完之后被唤醒执行，而在这个过程中主线程可以进行其他渲染任务</p>
<h4><a class="header" href="#异步javascript" id="异步javascript">异步JavaScript</a></h4>
<p>我们先来看<a href="https://mdn.github.io/learning-area/javascript/asynchronous/introducing/basic-function.html">同步的JavaScript</a>，即代码顺序执行</p>
<pre><code class="language-javascript">const btn = document.querySelector('button');
btn.addEventListener('click', () =&gt; {
  alert('You clicked me!');

  let pElem = document.createElement('p');
  pElem.textContent = 'This is a newly-added paragraph.';
  document.body.appendChild(pElem);
});
</code></pre>
<p>这个例子里，当我们按下按钮之后，直到关闭alter，后面的页面渲染都没有进行（这里alter只是为了演示，实际应用中不会用到它）</p>
<p>还有一个更实际的例子，我们要请求一张图片，然后将它显示在页面上</p>
<pre><code class="language-javascript">var response = fetch('myImage.png');
var blob = response.blob();
</code></pre>
<p>因为你不知道下载图片会多久，所以第二行代码执行的时候可能报错，因为图像还没有就绪。取代的方法就是，代码必须等到 <code>response</code> 返回才能继续往下执行，而这个时候，你的页面就会看上去像卡住了</p>
<h4><a class="header" href="#回调函数callbacks" id="回调函数callbacks">回调函数(callbacks)</a></h4>
<p>回调函数即作为参数传递给那些在后台执行的其他函数， 当那些后台运行的代码结束，就调用callbacks函数，通知你工作已经完成，或者其他有趣的事情发生了。</p>
<p>比如上面的<code>addEventListener</code>就是一个回调，他在监听的事件发生的时候被调用。但是注意，不是所有的回调函数都是异步的，比如用<code>forEach</code>来遍历数组时，传入的函数就是同步的。</p>
<p>由于我们在后面很少单纯用回调来实现异步（这种写法比较古老而且有一些缺点），这里只展示一个简单的例子</p>
<p><code>setTimeout</code>：在指定的时间后执行一段代码</p>
<p>可以思考一下在同步和异步的情况下这段代码的输出是什么样的</p>
<pre><code class="language-javascript">setTimeout(()=&gt;{console.log('hi');},20000);
console.log('bye');
</code></pre>
<p>有关回调函数，还有一个比较有意思的<a href="http://callbackhell.com/">回调地狱</a>的情况会出现</p>
<h4><a class="header" href="#promise" id="promise">Promise</a></h4>
<p>Promises 是新派的异步代码，现代的web APIs经常用到。先来看一个展示Promise基本语法的例子</p>
<pre><code class="language-js">fetch('products.json').then(function(response) {
  return response.json();
}).then(function(json) {
  products = json;
  initialize();
}).catch(function(err) {
  console.log('Fetch problem: ' + err.message);
});
</code></pre>
<p>这里的<code>fetch()</code> 返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a>. promise 是表示异步操作完成或失败的对象。可以说，它代表了一种中间状态。 本质上，这是浏览器说“我保证尽快给您答复”的方式，因此得名“promise”。而在上面的代码中，跟在promise后面的是</p>
<ul>
<li>两个 <code>then()</code> 块。两者都包含一个回调函数，如果前一个操作成功，该函数将运行，并且每个回调都接收前一个成功操作的结果作为输入，因此可以继续对它执行其他操作。每个 <code>.then()</code>块返回另一个promise，这意味着可以将多个<code>.then()</code>块链接到另一个块上，这样就可以依次执行多个异步操作。</li>
<li>如果其中任何一个<code>then()</code>块失败，则在末尾运行<code>catch()</code>块——与同步<code>try...catch</code>类似，<code>catch()</code>提供了一个错误对象，可用来报告发生的错误类型。</li>
</ul>
<p>Promise 对象本质上表示的是一系列操作的中间状态，或者说是未来某时刻一个操作完成或失败后返回的结果。Promise并不保证操作在何时完成并返回结果，但是保证在当前操作成功后执行您对操作结果的处理代码，或在操作失败后，优雅地处理操作失败的情况。</p>
<p>对比回调，Promise的优点可以从下面的代码中看出（模拟按顺序处理披萨订单）</p>
<p>回调的实现是这样的，就像上面的回调地狱，可读性差</p>
<pre><code class="language-javascript">chooseToppings(function(toppings) {
  placeOrder(toppings, function(order) {
    collectOrder(order, function(pizza) {
      eatPizza(pizza);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);
</code></pre>
<p>而用Promise我们可以这样实现</p>
<pre><code class="language-javascript">chooseToppings()
.then(toppings =&gt; placeOrder(toppings))
.then(order =&gt; collectOrder(order))
.then(pizza =&gt; eatPizza(pizza))
.catch(failureCallback);
</code></pre>
<h4><a class="header" href="#async-await" id="async-await">async await</a></h4>
<p><code>async</code>和<code>await</code>是在ECMAScript 2017中添加的promises的语法糖，使得异步代码更易于编写和后续阅读。</p>
<ul>
<li>
<p>首先，我们使用<code>async</code>关键字，将它放在函数声明之前，将其转换为<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async function</a>。异步函数是一个知道怎样预期 await 关键字可用于调用异步代码可能性的函数。而async函数调用返回的是一个promise</p>
<pre><code class="language-javascript">const hello = async () =&gt; { return &quot;Hello&quot; };
hello();
//Promise {&lt;resolved&gt;: &quot;Hello&quot;}
</code></pre>
<p>当然这个Promise可以像之前提到的一样后接<code>.then()</code>等等来使用。我们只需要在需要异步执行的函数前添加<code>async</code>关键字，JavaScript引擎就可以优化你的程序</p>
</li>
<li>
<p>与<code>awiat</code>关键字结合可以体现出他们的真正优势，<code>awiat</code>可以用在异步函数中，他会使得暂停代码在该行上，直到promise完成，然后返回结果值。可以在调用任何返回Promise的函数时使用<code>await</code>。</p>
</li>
</ul>
<p>我们通过一个例子来看下它与Promise的区别</p>
<p><strong>Promise</strong></p>
<pre><code class="language-javascript">fetch('coffee.jpg')
.then(response =&gt; response.blob())
.then(myBlob =&gt; {
  let objectURL = URL.createObjectURL(myBlob);
  let image = document.createElement('img');
  image.src = objectURL;
  document.body.appendChild(image);
})
.catch(e =&gt; {
  console.log('There has been a problem with your fetch operation: ' + e.message);
});
</code></pre>
<p><strong>async await</strong></p>
<pre><code class="language-javascript">async function myFetch() {
  try {
    let response = await fetch('coffee.jpg');
    let myBlob = await response.blob();

    let objectURL = URL.createObjectURL(myBlob);
    let image = document.createElement('img');
    image.src = objectURL;
    document.body.appendChild(image);
  } catch(e) {
    console.log(e);
  }
}

myFetch();
</code></pre>
<p>使用async、await会使你的代码看起来更像是同步代码，读起来也十分容易理解，因为他实际上就是在顺序执行，但是在等待await的时候并不会产生阻塞，影响其他渲染任务</p>
<h2><a class="header" href="#typescript" id="typescript">TypeScript</a></h2>
<blockquote>
<p>更加深入的学习可以参考<a href="https://www.typescriptlang.org/docs/home.html">官方文档</a>（<a href="https://www.tslang.cn/index.html">中文</a>），在这里我们做简单介绍</p>
</blockquote>
<p>JavaScript 是一个不具有强类型的动态语言，这赋予了它极大的灵活性，但也带来了开发和生产上可能存在的问题。TypeScript 是 JavaScript 的超集，使得 JavaScript 中的每一个变量和函数都具有和 C 一样的类型定义。你可以利用 TypeScript 在编译期进行类型检查，提前发现错误。我们在使用ts的时候，最终还是会将其编译为js代码，但是在编译的时候会进行静态类型检查如果发现有错误，编译的时候就会报错。</p>
<h3><a class="header" href="#类型注解" id="类型注解">类型注解</a></h3>
<p>TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。我们可以简单的使用<code>:</code>来添加类型注解，例如</p>
<pre><code class="language-typescript">function greeter(person: string) {
    return &quot;Hello, &quot; + person;
}
let user = [0, 1, 2];

greeter(user);
//greeter.ts(7,26): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.
</code></pre>
<p>在此展示最简单的基础类型</p>
<pre><code class="language-typescript">//布尔值
let isDone: boolean = false;

//数字
let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;

//字符串
let name: string = &quot;bob&quot;;
name = &quot;smith&quot;;
let sentence: string = `Hello, my name is ${ name }.`

//数组
let list: number[] = [1, 2, 3];
let list: Array&lt;number&gt; = [1, 2, 3];

//元组,表示一个已知元素数量和类型的数组，各元素的类型不必相同
// Declare a tuple type
let x: [string, number];
// Initialize it
x = ['hello', 10]; // OK
// Initialize it incorrectly
x = [10, 'hello']; // Error

//枚举
enum Color {Red, Green, Blue}
let c: Color = Color.Green;

//Void，表示一个函数没有返回值
function warnUser(): void {
    console.log(&quot;This is my warning message&quot;);
}

//Null 和 Undefined
let u: undefined = undefined;
let n: null = null;
//他们是所有类型的子类型
// 这样不会报错
let num: number = undefined;
</code></pre>
<p>这里单独说一下<code>any</code>，任意值（Any）用来表示允许赋值为任意类型，并且你可以对其访问任何属性，调用任何方法。它主要用于为那些在编程阶段还不清楚类型的变量指定一个类型，比如来自用户输入或第三方代码库的内容。如果你在声明变量的时候没有指定类型和初值，他会被识别为<code>any</code>类</p>
<pre><code class="language-typescript">let myFavoriteNumber: any = 'seven';
myFavoriteNumber = 7;

let something;
something = 'seven';
something = 7;
</code></pre>
<p>下面给出指定函数类型的例子</p>
<pre><code class="language-typescript">//完整
let myAdd: (x: number, y: number) =&gt; number =
    function(x: number, y: number): number { return x + y; };

//推断
// myAdd has the full function type
let myAdd = function(x: number, y: number): number { return x + y; };

// The parameters `x` and `y` have the type number
let myAdd: (baseValue: number, increment: number) =&gt; number =
    function(x, y) { return x + y; };
</code></pre>
<p>ts也可以设定可选参数以及参数默认值，可选参数在参数后加?即可</p>
<pre><code class="language-typescript">let myAdd = function(x: number = 1, y?: number): number { ...};
</code></pre>
<h3><a class="header" href="#类型断言" id="类型断言">类型断言</a></h3>
<p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。</p>
<p>类型断言的两种方式为</p>
<pre><code class="language-typescript">let someValue: any = &quot;this is a string&quot;;

let strLength1: number = (&lt;string&gt;someValue).length;

let strLength2: number = (someValue as string).length;
</code></pre>
<h3><a class="header" href="#联合类型" id="联合类型">联合类型</a></h3>
<p>联合类型（Union Types）表示取值可以为多种类型中的一种。联合类型使用 <code>|</code> 分隔每个类型。</p>
<pre><code class="language-typescript">let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;
</code></pre>
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong></p>
<pre><code class="language-typescript">function getLength(something: string | number): number {
    return something.length;
}

// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.
//   Property 'length' does not exist on type 'number'.
</code></pre>
<p>这时候我们就可以用到上面的类型断言</p>
<h3><a class="header" href="#类型别名" id="类型别名">类型别名</a></h3>
<p>我们使用 <code>type</code> 创建类型别名，类型别名常用于联合类型</p>
<pre><code class="language-ts">type Name = string;
type NameResolver = () =&gt; string;
type NameOrResolver = Name | NameResolver;
</code></pre>
<h3><a class="header" href="#a-hrefhttpswwwtslangcndocshandbookinterfaceshtml接口a" id="a-hrefhttpswwwtslangcndocshandbookinterfaceshtml接口a"><a href="https://www.tslang.cn/docs/handbook/interfaces.html">接口</a></a></h3>
<p>TypeScript的核心原则之一是对值所具有的<em>结构</em>进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。简单的说，在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。</p>
<pre><code class="language-typescript">interface Person {
    name: string;
    age: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25
};

let jack: Person = {
    name: 'Jack'
};
// index.ts(6,5): error TS2322: Type '{ name: string; }' is not assignable to type 'Person'.
//   Property 'age' is missing in type '{ name: string; }'.
</code></pre>
<p>当然也可以加入可选属性，上面的错误可以这样解决</p>
<pre><code class="language-typescript">interface Person {
    name: string;
    age?: number;
}
let jack: Person = {
    name: 'Jack'
};
</code></pre>
<h3><a class="header" href="#a-hrefhttpswwwtslangcndocshandbookgenericshtml泛型a" id="a-hrefhttpswwwtslangcndocshandbookgenericshtml泛型a"><a href="https://www.tslang.cn/docs/handbook/generics.html">泛型</a></a></h3>
<p>这个概念和C/C++里的模板比较相似，由于刚学过在此不作讲解，具体可以在读代码的时候学习</p>
<pre><code class="language-C++">template &lt;typename T&gt;
</code></pre>
<pre><code class="language-typescript">function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;
</code></pre>
<p>EESAST前端代码中的一个例子</p>
<pre><code class="language-typescript">const columns: ColumnProps&lt;ITeam&gt;[] = [];
</code></pre>
<h3><a class="header" href="#a-hrefhttpswwwtslangcndocshandbookmoduleshtml模块a" id="a-hrefhttpswwwtslangcndocshandbookmoduleshtml模块a"><a href="https://www.tslang.cn/docs/handbook/modules.html">模块</a></a></h3>
<p>任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加<code>export</code>关键字来导出。</p>
<p>可以在声明的时候直接导出</p>
<pre><code class="language-typescript">export interface StringValidator {
    isAcceptable(s: string): boolean;
}

export const numberRegexp = /^[0-9]+$/;

export class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
</code></pre>
<p>也可以在声明之后的任意位置导出，并且可以重命名</p>
<pre><code class="language-typescript">class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
export { ZipCodeValidator };
export { ZipCodeValidator as mainValidator };
</code></pre>
<p>在导入的时候，可以直接导入，也可以进行重命名</p>
<pre><code class="language-typescript">import { ZipCodeValidator } from &quot;./ZipCodeValidator&quot;;

import { ZipCodeValidator as ZCV } from &quot;./ZipCodeValidator&quot;;
</code></pre>
<p>每个模块都可以有一个<code>default</code>导出。 默认导出使用 <code>default</code>关键字标记；并且一个模块只能够有一个<code>default</code>导出。对于<code>default</code>模块在导入的时候不必加大括号，而且可以直接重命名</p>
<pre><code class="language-typescript">//OneTwoThree.ts
export default &quot;123&quot;;
</code></pre>
<pre><code class="language-typescript">import num from &quot;./OneTwoThree&quot;;
</code></pre>
<h1><a class="header" href="#react--antd-入门教程" id="react--antd-入门教程">React + antd 入门教程</a></h1>
<blockquote>
<p>本节内容相关代码请访问<a href="https://github.com/duskmoon314/react-tutorial">react-tutorial</a>，<a href="https://duskmoon314.github.io/react-tutorial/chapter1/chapter_1.html">文档</a></p>
</blockquote>
<h2><a class="header" href="#说明" id="说明">说明</a></h2>
<p>本节将使用 Yarn 作为包管理，用 Node.js 运行一个 React App，结合 antd 组件从头开始搭建一个小游戏作为入门。会介绍以下内容：</p>
<ul>
<li>什么是 Node.js？如何使用 Yarn 进行包管理？</li>
<li>如何<strong>初始化</strong>一个使用 TypeScript 的 React 应用？</li>
<li>React 和 antd 分别是干什么的？</li>
<li>前端需要做些什么？</li>
</ul>
<blockquote>
<p>小游戏借鉴了<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html">Rust 文档</a>。对优质文档和启发灵感表示感谢。</p>
</blockquote>
<h2><a class="header" href="#相关依赖" id="相关依赖">相关依赖</a></h2>
<blockquote>
<p>本节内容的详细文档提供了使用 CodeSandbox 的在线环境与各阶段代码，如果读者自行配置环境遇到困难，可以尝试使用。出于一些原因，CodeSandbox 中的代码会与文档有些微的区别，但不涉及到本节说要讲解内容的重点。</p>
</blockquote>
<ul>
<li>Node.js 和 Yarn：请参阅<a href="https://duskmoon314.github.io/react-tutorial/chapter1/chapter_1.html">文档</a>进行安装</li>
<li>React</li>
<li>antd</li>
</ul>
<h1><a class="header" href="#后端技术栈入门" id="后端技术栈入门">后端技术栈入门</a></h1>
<p>本讲主要为使用Node.js结合Express和Mongo的RESTful后端开发入门指南。准备工作需要安装以下工具并设置环境变量。</p>
<ul>
<li><a href="https://nodejs.org/en/">Node.js</a></li>
<li><a href="https://yarnpkg.com/zh-Hant/docs/install">Yarn</a></li>
<li><a href="https://www.mongodb.com/try/download/community">MongoDB</a></li>
<li><a href="https://www.postman.com/downloads/">Postman</a></li>
</ul>
<p>本讲演示样例为<a href="https://eesast.com">清华电子系学生科协网站</a>在2020年5月1日前的前后端代码（现已从REST迁移至GraphQL），代码开源于<a href="https://github.com/eesast/web/tree/c2e3b521b7093d9bbb67c4e74209235d1fff9808">前端代码</a>与<a href="https://github.com/eesast/api/tree/ba7cce4a4a773fc2ce35bb137be9d02cd581d4b5">后端代码</a>，代码也已复制至本仓库中，可在协议许可的范围内学习使用。</p>
<p>本讲主要介绍：</p>
<ul>
<li>RESTful</li>
<li>Node.js</li>
<li>Express</li>
<li>MongoDB</li>
<li>Postman使用</li>
</ul>
<p>详情请查看<a href="https://github.com/eesast/training2020/tree/master/web/backend">课程代码及其文档</a>。</p>
<h1><a class="header" href="#graphql-hasura-postgresql-apollo" id="graphql-hasura-postgresql-apollo">GraphQL, Hasura, PostgreSQL, Apollo</a></h1>
<blockquote>
<p>本节介绍 GraphQL、Hasura、PostgreSQL（关系型数据库）、Apollo，这是目前网站主要拉取数据的方案。</p>
</blockquote>
<p>四个部分大致是如下图构成数据查询流程。即编写查询相关的 GraphQL 语句，Apollo 会生成相应的 TS 代码，经编译后运行在 Node.js 上，使用 GraphQL 的形式与 Hasura 进行交互，由 Hasura 访问 PostgreSQL 数据库存取数据。</p>
<p><img src="web/./images/gql.drawio.svg" alt="GraphQL、Hasura、Apollo、PostgreSQL的架构" /></p>
<p>接下来，将逐步讲解以下概念：</p>
<ul>
<li>什么是“关系型数据库”？SQL 又是什么？</li>
<li>从 SQL 到 GraphQL</li>
<li>使用 Hasura+PostgreSQL 来管理数据</li>
<li>使用 Apollo 编写查、增、删、改</li>
</ul>
<p>相关链接：</p>
<ul>
<li><a href="https://graphql.org/">GraphQL</a></li>
<li><a href="https://hasura.io/">Hasura</a></li>
<li><a href="https://www.apollographql.com/docs/react/v3.0-beta">Apollo Client (React)</a></li>
</ul>
<h2><a class="header" href="#关系型数据库与-sql" id="关系型数据库与-sql">关系型数据库与 SQL</a></h2>
<p>数据库，顾名思义是存储数据的。我们常用实体-联系的方式来对数据进行抽象，其中实体是客观存在并可相互区分的事物，而联系指的是不同（类）实体之间的关系。关系型数据库指的是使用关系模型来存储数据。</p>
<p><img src="web/./images/ER.drawio.svg" alt="实体联系例图" /></p>
<p>不同实体间的联系一般分为“一对一”、“一对多”、“多对多”三种，可以借助三个例子理解：</p>
<ul>
<li>一对一：一个班有一个班主任，一个班主任负责一个班</li>
<li>一对多：一个作者可以写多篇文章</li>
<li>多对多：一个用户可以关注多个用户，同时被多个用户关注</li>
</ul>
<p>而关系模型则是使用一张表来存储数据，比如</p>
<table><thead><tr><th>用户信息</th><th></th><th></th></tr></thead><tbody>
<tr><td>id</td><td>用户名</td><td>性别</td></tr>
<tr><td>1</td><td>张三</td><td>男</td></tr>
<tr><td>2</td><td>古河渚</td><td>女</td></tr>
<tr><td>3</td><td>秀吉</td><td>秀吉</td></tr>
</tbody></table>
<p>表中每列是一个属性，每行是一个实体的数据（也称元组）。总应有至少一个属性可以唯一标识元组，称为候选码，选其中一个作为主码。部分属性可能是其他关系表中的主码，称为外码。我们会在接下来的例子中看到这些“码”。</p>
<p>SQL（Structured Query Language，结构化查询语言）是用来对数据进行查询、添加、删除、更改的语言，这里只简单介绍查询功能。假定我们有三个表分别存学生、课程、学生-课程，我们可以使用如下的 SQL 语句进行查询：</p>
<pre><code class="language-sql">查询全体学生的学号和姓名
SELECT stu_no, stu_name
FROM Student;

查选修C1课程的学生的学号和成绩，并按分数降序排列
SELECT stu_no, grade
FROM StudentCourse
WHERE course_no='C1'
ORDER BY grade DESC;
</code></pre>
<blockquote>
<p>更多有关 SQL 的内容不是培训重点，建议感兴趣的同学自行学习。</p>
</blockquote>
<h2><a class="header" href="#graphql" id="graphql">GraphQL</a></h2>
<p>SQL 较为古老，对于数据量大且关系复杂的查询不够直观，GraphQL 则是一个更为直观的查询语言。</p>
<p>在 JS / json 中，我们使用类似的结构来表示对象</p>
<pre><code class="language-json">[
  {
    &quot;username&quot;: &quot;Zhang San&quot;,
    &quot;gender&quot;: &quot;male&quot;
  },
  {
    &quot;username&quot;: &quot;Nagisa&quot;,
    &quot;gender&quot;: &quot;female&quot;
  }
]
</code></pre>
<p>我们可以使用极为相似的 GraphQL 语句来查询</p>
<pre><code class="language-graphql">query {
  user {
    username
  }
}
</code></pre>
<p>得到相应的 json 结果</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;user&quot;: [
      {
        &quot;username&quot;: &quot;Zhang San&quot;
      },
      {
        &quot;username&quot;: &quot;Nagisa&quot;
      }
    ]
  }
}
</code></pre>
<p>一个更为复杂的例子</p>
<pre><code class="language-graphql">query GetArticleFeeds(
  $limit: Int = 2
  $cursor: timestamptz!
  $authorId: String
  $title: String
  $alias: String
  $abstract: String
  $content: String
) {
  article_public(
    limit: $limit
    where: {
      _and: [
        { created_at: { _lte: $cursor } }
        { authorId: { _eq: $authorId } }
        { title: { _ilike: $title } }
        { alias: { _ilike: $alias } }
        { abstract: { _ilike: $abstract } }
        { content: { _ilike: $content } }
      ]
    }
    order_by: { created_at: desc }
  ) {
    id
    alias
    title
    abstract
    views
    created_at
    author {
      username
    }
    article_tags {
      tag {
        tag_name
      }
    }
    article_likers_aggregate {
      aggregate {
        count(distinct: true)
      }
    }
  }
}
</code></pre>
<p>这是正在开发的 Weekly 用来获取文章信息的语句（可能会有更改）。最前面的$加字符串表示查询语句中使用的变量，后面加感叹号表示该项必须存在。这些变量在下方的<code>where</code>中使用，用来限制查询结果。最后面的花括号中包含的内容是要得到的数据，其中<code>author</code>、<code>article_tags</code>和<code>articl_likers_aggregate</code>是利用外码获取对应的作者信息、标签信息、喜欢文章的用户的统计信息。</p>
<p>用于更改（增删）的语句则使用<code>mutation</code>关键字</p>
<pre><code class="language-graphql">mutation InsertArticle(
  $abstract: String = &quot;&quot;
  $alias: String!
  $content: String!
  $authorId: String!
  $title: String!
  $tags: [article_tag_insert_input!]! = []
) {
  insert_article_one(
    object: {
      abstract: $abstract
      alias: $alias
      content: $content
      authorId: $authorId
      title: $title
      article_tags: {
        data: $tags
        on_conflict: { constraint: article_tag_pkey, update_columns: tag_id }
      }
    }
    on_conflict: { constraint: article_alias_key, update_columns: [] }
  ) {
    id
  }
}
</code></pre>
<p>这段语句将基于给定的变量，创建一篇文章，并返回文章的 id。</p>
<h2><a class="header" href="#hasura-和-postgresql" id="hasura-和-postgresql">Hasura 和 PostgreSQL</a></h2>
<p>前面讲的 GraphQL 看上去很美化，但要自行实现相应的 API 不是一件容易的事，因此我们选用 Hasura GraphQL Engine。</p>
<p>Hasura 是开源的 GraphQL 引擎，默认使用 PostgreSQL 数据库存储数据，可以使用其提供的 console 页面创建数据表、增删改数据、设置操作权限、测试 GraphQL 语句。下面将从安装开始“浏览”基本使用。</p>
<h3><a class="header" href="#安装" id="安装">安装</a></h3>
<p>参照官方文档，我们使用 docker 进行安装。首先修改官方提供的<code>docker-compose.yaml</code></p>
<pre><code class="language-yaml">version: &quot;3.6&quot;
services:
  postgres:
    image: postgres:latest
    container_name: postgres
    restart: always
    volumes:
      - ~/data/postgres:/var/lib/postgresql/data
    ports:
      - &quot;5432:5432&quot;
    environment:
      POSTGRES_PASSWORD: postgrespassword
  graphql-engine:
    image: hasura/graphql-engine:latest
    container_name: hasura
    ports:
      - &quot;23333:8080&quot;
    depends_on:
      - &quot;postgres&quot;
    restart: always
    environment:
      HASURA_GRAPHQL_DATABASE_URL: postgres://postgres:postgrespassword@postgres:5432/postgres
      HASURA_GRAPHQL_ENABLE_CONSOLE: &quot;true&quot; # set to &quot;false&quot; to disable console
      HASURA_GRAPHQL_ENABLED_LOG_TYPES: startup, http-log, webhook-log, websocket-log, query-log
      ## uncomment next line to set an admin secret
      # HASURA_GRAPHQL_ADMIN_SECRET: myadminsecretkey
</code></pre>
<p>注意其中需要修改的几处地方：</p>
<ul>
<li>容器端口绑定宿主机端口是否会冲突</li>
<li>PostgreSQL 的密码是否需要设置</li>
<li>Hasura 的密码是否需要设置（默认不设置）</li>
</ul>
<p>在修改好后的<code>docker-compose.yaml</code>所在路径使用如下命令拉取镜像并启动容器</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
<p>启动后，我们使用<code>docker ps -a</code>可以查看容器状态（类似下方所示）</p>
<pre><code class="language-bash">CONTAINER ID IMAGE                 ... CREATED STATUS PORTS                        ...
097f58433a2b hasura/graphql-engine ... 1m ago  Up 1m  0.0.0.0:23333-&gt;8080/tcp      ...
b0b1aac0508d postgres              ... 1m ago  Up 1m  0.0.0.0:5432-&gt;5432/tcp       ...
</code></pre>
<p>现在访问<code>localhost:23333/console</code>可以进入 Hasura 的控制界面</p>
<p><img src="web/./images/hasura_console.png" alt="Hasura Console" /></p>
<p>Hasura 提供许多功能，我们主要使用<code>GRAPHIQL</code>和<code>DATA</code>两个页面的功能</p>
<h3><a class="header" href="#创建与管理数据" id="创建与管理数据">创建与管理数据</a></h3>
<p>在<code>DATA</code>页面可以创建“关系表”，比如创建一个<code>user</code>：</p>
<p><img src="web/./images/hasura_create_table.png" alt="create table" /></p>
<p>这里填入了 6 个属性，其中<code>_id</code>为主码，使用数据库的 uuid 生成器得到。<code>username</code>、<code>email</code>、<code>gender</code>皆为字符串，其中<code>username</code>也是不可重复的（我们称为候选码），而<code>email</code>和<code>gender</code>则是可以为空的普通属性。<code>created_at</code>和<code>updated_at</code>则是使用<code>+ Frequently used columns</code>添加的，分别会根据创建和更改时的时间自动添加。</p>
<p>我们再来创建一个<code>article</code>表，加入作者的<code>_id</code>作为外码：</p>
<p><img src="web/./images/hasura_foreign_key.png" alt="foreign key" /></p>
<p>这里将<code>author</code>的值设为 uuid 类型，并与<code>user._id</code>严格一致。我们点开<code>article</code>的<code>Relationships</code>可以看到推荐的关系设置：</p>
<p><img src="web/./images/hasura_relations.png" alt="relationships" /></p>
<p>这里推荐添加<code>Object relationships</code>，而在<code>user</code>的<code>Relationships</code>可以看到推荐<code>Array relationships</code>。点击添加便是告诉 Hasura 这两个表之间是一对多的关系，即一个<code>user</code>可以有多篇<code>article</code>。我们可以在<code>GRAPHIQL</code>页面试着写一下查询语句：</p>
<p><img src="web/./images/hasura_graphiql.png" alt="graphiql" /></p>
<p>一般限制条件不太复杂的查询或者更改操作，都可以使用最左侧的 Explorer 勾选需要的部分，由 Hasura 生成中间的语句，点击“执行”按钮可以在右边看到结果。这里因为还没有添加数据，所以是空的。</p>
<p>对于更为复杂的关系，比如“喜欢一篇文章”这种多对多关系，我们需要再创建一个表，只有<code>article_id</code>和<code>user_id</code>两个属性，一起作为主码，又同时是外码。当表中存在这样的数据时，就表明某用户喜欢某篇文章。</p>
<p>最后我们再看一下“权限控制”。在表的<code>Permissions</code>页面可以设置不同身份用户的插入、查询、更改与删除权限。目前 Hasura 提供的权限设置自由度较小，如果要设置非常复杂的权限，需要通过添加数据表的<code>view</code>再给其设置权限等方法来实现。具体细节可以参看<a href="https://hasura.io/docs/1.0/graphql/manual/auth/authorization/role-multiple-rules.html#role-multiple-rules">Multiple column + row permissions for the same role</a></p>
<p><img src="web/./images/hasura_permissions.png" alt="permission" /></p>
<h2><a class="header" href="#apollo" id="apollo">Apollo</a></h2>
<p>我们这里说的 Apollo 主要指的是 Apollo Client (React)，实现了拉取并管理数据的功能。Apollo 本身会根据配置好的服务端的数据，将本地写好的<code>GraphQL</code>语句编译为<code>typescript</code>接口。</p>
<p>目前的前端项目中，我们在<code>src/api</code>文件夹下编写<code>*.graphql</code>文件，即填写在 Hasura 中测试过得到需要结果的<code>query</code>或<code>mutation</code>语句。之后使用 Apollo 的<code>codegen</code>编译为相应的接口，供前端页面拉取数据使用。</p>
<p><img src="web/./images/apollo_typests.png" alt="Apollo types.ts" /></p>
<p>我们使用 Apollo 提供的<code>useQuery</code>和<code>useMutation</code>来进行数据的获取和更改。参考官方文档使用<code>useQuery</code>：</p>
<pre><code class="language-javascript">const GET_DOG_PHOTO = gql`
  query Dog($breed: String!) {
    dog(breed: $breed) {
      id
      displayImage
    }
  }
`;

function DogPhoto({ breed }) {
  const { loading, error, data } = useQuery(GET_DOG_PHOTO, {
    variables: { breed },
  });

  if (loading) return null;
  if (error) return `Error! ${error}`;

  return (
    &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt;
  );
}
</code></pre>
<p>观察到有一个变量，存的是 GraphQL 的语句，并将这个变量传入<code>useQuery</code>，返回的是<code>data</code>、<code>loading</code>和<code>error</code>三项。顾名思义，是返回的数据、加载状态与是否错误。迁移到<code>typescript</code>是类似这样的：</p>
<pre><code class="language-graphql">query GetUser($_id: String!) {
  user(where: { _id: { _eq: $_id } }) {
    _id
    id
    name
    username
    department
    class
    phone
    email
  }
}
</code></pre>
<pre><code class="language-typescript">import { GetUser as GET_USER } from &quot;../api/user.graphql&quot;;
import { GetUser, GetUserVariables } from &quot;../api/types&quot;;
const { data, loading, error } = useQuery&lt;GetUser, GetUserVariables&gt;(GET_USER, {
  variables: { _id: userData?._id! },
});
</code></pre>
<p>这里从<code>user.graphql</code>中导入了<code>GetUser</code>的片段并起别名叫<code>GET_USER</code>，并从 Apollo 生成的接口中导入<code>GetUser</code>和<code>GetUserVariables</code>，即告诉<code>useQuery</code>要使用<code>GET_USER</code>的形式发送请求。之后每次渲染<code>useQuery</code>所在的组件时，便会执行这个请求拉取用户信息。</p>
<p>而<code>mutation</code>所用的<code>useMutation</code>则是会创建一个函数，显式调用以进行更改的操作。</p>
<pre><code class="language-graphql">mutation UpdateUser(
  $_id: String!
  $id: bigint!
  $username: String
  $phone: String
  $name: String
  $department: String
  $class: String
  $email: String
) {
  update_user(
    where: { _id: { _eq: $_id } }
    _set: {
      id: $id
      username: $username
      phone: $phone
      name: $name
      department: $department
      class: $class
      email: $email
    }
  ) {
    affected_rows
  }
}
</code></pre>
<pre><code class="language-typescript">import { UpdateUser as UPDATE_USER } from &quot;../api/user.graphql&quot;;
import { UpdateUser, UpdateUserVariables } from &quot;../api/types&quot;;
const [
  updateUser,
  { data: updateData, loading: updating, error: updateError },
] = useMutation&lt;UpdateUser, UpdateUserVariables&gt;(UPDATE_USER);
</code></pre>
<p>下面我们来看查询和更改的例子。我们在数据库里存了很多文章，现在我们要获取并用一个列表展示它们。当用户点击文章时会跳转到相应页面进行阅读，同时更改数据库中该文章的<code>view</code>属性（加 1）。</p>
<p><img src="web/./images/apollo_query.png" alt="query" /></p>
<pre><code class="language-typescript">const { data, loading, error } = useQuery&lt;
  GetArticleFeeds,
  GetArticleFeedsVariables
&gt;(GET_ARTICLE_FEEDS, {
  variables: { limit: 5, cursor: cursor },
});

useEffect(() =&gt; {
  if (data) {
    setArticles(
      data.article_public.map((article) =&gt; {
        return {
          title: article.title!,
          alias: article.alias!,
          abstract: article.abstract!,
          author: article.author?.username!,
          likes: article.article_likers_aggregate.aggregate?.count!,
          views: article.views!,
          tags: article.article_tags.map((t) =&gt; t.tag.tag_name),
        };
      })
    );
  }
}, [data]);

return (
  &lt;Row&gt;
    &lt;Col span={4}&gt;&lt;/Col&gt;
    &lt;Col span={16}&gt;
      &lt;List
        dataSource={articles}
        renderItem={(item) =&gt; {
          return (
            &lt;Link to={`/weekly/explore/${item.alias}`}&gt;
              &lt;ArticleFeedCard article={item} /&gt;
            &lt;/Link&gt;
          );
        }}
      &gt;&lt;/List&gt;
    &lt;/Col&gt;
    &lt;Col span={4}&gt;&lt;/Col&gt;
  &lt;/Row&gt;
);
</code></pre>
<p>这里使用<code>useQuery</code>，基于<code>cursor</code>（用来确定获取文章的时间戳，初始化为当前时间）拉取 5 篇文章，并使用<code>map</code>变为<code>&lt;ArticleFeedCard /&gt;</code>组件接收的参数。</p>
<p><img src="web/./images/apollo_mutation.png" alt="mutation" /></p>
<pre><code class="language-typescript">const [
  viewArticle,
  { data: articleData, loading: articleLoading, error: articleError },
] = useMutation&lt;ViewArticle, ViewArticleVariables&gt;(VIEW_ARTICLE);

useEffect(() =&gt; {
  viewArticle({
    variables: { alias: alias },
  });
}, [alias, viewArticle]);

useEffect(() =&gt; {
  if (articleData &amp;&amp; !articleError &amp;&amp; articleData.update_article_public) {
    setArticle(articleData?.update_article_public?.returning[0]);
    setContentHtml(
      md2wx.renderHtml(
        articleData?.update_article_public?.returning[0].content!
      )
    );
  }
}, [articleData, articleError]);
</code></pre>
<p>在文章的阅读页面，则是使用<code>mutation</code>同时修改<code>view</code>并获取文章的内容，再存储到组件的状态中，以备其他功能需要。</p>
<p>Apollo 的简短介绍到这里就结束了，对于更深内容感兴趣的同学可以自行查阅其文档学习。</p>
<hr />
<h2><a class="header" href="#写在最后" id="写在最后">写在最后</a></h2>
<p>GraphQL 整体上是比较新的一种技术，直观是其优势。同时，也因为较新，轮子会相对少一些，有中文文档的轮子就更少了。此外，部分轮子还在迅速的演进，会有较多的<strong>BREAKING CHANGE</strong>，有可能代码刚写完，不小心更新一下依赖就挂掉了（笑）。为了减少这种更新带来的麻烦，我们一般会使用“机器人”来尝试更新依赖，即持续集成。具体内容将在下一节中讲解。</p>
<h1><a class="header" href="#linux-入门实操" id="linux-入门实操">Linux 入门实操</a></h1>
<blockquote>
<p>基本上是翻译了下<a href="https://missing.csail.mit.edu/2020">missing-semester</a>的 1、3 讲</p>
<p>写完这个发现 missing-semester 有<a href="https://missing-semester-cn.github.io/">中文版</a>orz</p>
</blockquote>
<h2><a class="header" href="#说明-1" id="说明-1">说明</a></h2>
<p>此处的文档为本次课程的 linux 实操部分，其他课件请见<a href="https://github.com/eesast/training2020/blob/master/basic_tool/linux-webserver">此处</a></p>
<h2><a class="header" href="#shell-基础" id="shell-基础">Shell 基础</a></h2>
<h3><a class="header" href="#shell-使用" id="shell-使用">shell 使用</a></h3>
<p>打开 shell 之后首先看到这样的提示符</p>
<pre><code class="language-shell">zxdclyz@Lyz:~$
</code></pre>
<p>用户名@设备名:当前路径，<code>~</code>代表 home 家路径</p>
<p>此时就可以输入命令了</p>
<pre><code class="language-shell">zxdclyz@Lyz:~$ date
Sat Jun 20 20:07:17 CST 2020
zxdclyz@Lyz:~$
</code></pre>
<p>通过输入 date 运行了 date 这个打印日期和时间的程序，然后提示符重新出现，告诉我们可以输入下一条命令</p>
<p>另一个十分基础的命令是 echo</p>
<pre><code class="language-shell">zxdclyz@Lyz:~$ echo hello world
hello world
</code></pre>
<p>echo 的作用是直接打印它的参数，在 shell 中，命令是以空格隔断的，第一个词指定运行的程序，后面的是参数，如果想要在一个参数中包括空格，可以使用<code>'</code>或者<code>&quot;</code>，也可以用<code>\(space)</code></p>
<pre><code class="language-shell">zxdclyz@Lyz:~$ echo 'hello world'
hello world
zxdclyz@Lyz:~$ echo hello\ world
hello world
</code></pre>
<p>不过在 echo 中看不出区别 orz</p>
<p>那么我们输入 date、echo 运行的是什么程序呢？shell 也是一个编程环境，类似 python，其中也有变量，如果输入了程序关键字之外的字段，shell 会去查找<code>$PATH</code>环境变量中的路径</p>
<pre><code class="language-shell">zxdclyz@Lyz:~$ echo $PATH
/usr/local/sbin:/usr/local/bin
</code></pre>
<p>其中的路径用<code>:</code>分隔，可以用<code>which</code>命令查看运行的程序所在路径</p>
<pre><code class="language-shell">zxdclyz@Lyz:~$ which echo
/bin/echo
</code></pre>
<p>如果程序所在路径不在环境变量里，也可以直接使用其完整路径来调用</p>
<pre><code class="language-shell">zxdclyz@Lyz:~$ /bin/echo eesast
eesast
</code></pre>
<h3><a class="header" href="#文件系统" id="文件系统">文件系统</a></h3>
<p>有关文件操作，<code>pwd</code>显示当前路径，<code>cd</code>改变路径，<code>ls</code>打印当前目录中的文件，<code>.</code>指当前目录，<code>..</code>指上级目录</p>
<pre><code class="language-shell">zxdclyz@Lyz:~/tutorial$ ls
a.txt  b.py  c.js
zxdclyz@Lyz:~/tutorial$ cd ../
zxdclyz@Lyz:~$ pwd
/home/zxdclyz
zxdclyz@Lyz:~$
</code></pre>
<p>使用<code>cd -</code>可以跳转到刚才所在的路径，用<code>mkdir</code>创建文件夹，<code>mv</code>移动文件，<code>cp</code>复制文件，<code>rm</code>删除文件，<code>touch</code>创建文件</p>
<p>有关文件权限，参考课件</p>
<h3><a class="header" href="#查看命令参数" id="查看命令参数">查看命令参数</a></h3>
<p>可以使用<code>man command</code>来进入手册页，也可以直接使用--help 参数查看</p>
<pre><code class="language-shell">zxdclyz@Lyz:/bin$ ls --help
...
zxdclyz@Lyz:/bin$ man ls
</code></pre>
<h3><a class="header" href="#连接程序" id="连接程序">连接程序</a></h3>
<p>在 shell 中，程序也有输入流和输出流，我们可以用<code>&gt; file</code>和<code>&lt; file</code>来重新引导流</p>
<pre><code class="language-shell">zxdclyz@Lyz:~/tutorial$ echo hello &gt; hello.txt
zxdclyz@Lyz:~/tutorial$ echo bye &gt;&gt; hello.txt
</code></pre>
<p>使用<code>&gt;&gt;</code>可以进行追加写</p>
<p>另一个十分有用的工具是 pipe<code>|</code>，它可以连接两个命令，将前一个命令的输出当做后一个命令的输入</p>
<pre><code class="language-shell">zxdclyz@Lyz:~/tutorial$ cat hello.txt
hello
bye
hello world
zxdclyz@Lyz:~/tutorial$ cat hello.txt|grep world
hello world
</code></pre>
<h2><a class="header" href="#vim-极简入门" id="vim-极简入门">Vim 极简入门</a></h2>
<p>如果你在使用服务器并且想简单地对一个文件进行编辑，使用 vim 是十分方便的（大量编辑我倾向于使用 VSCode 等远程连接），vim 本身拥有十分强大的功能，但我自己也并不会，所以只在此展示最基础的用法</p>
<p>使用<code>vim file</code>打开文件进行编辑</p>
<p>刚进入时处于正常模式，而 vim 中有这些模式</p>
<ul>
<li><strong>Normal</strong>: for moving around a file and making edits</li>
<li><strong>Insert</strong>: for inserting text</li>
<li><strong>Replace</strong>: for replacing text</li>
<li><strong>Visual</strong> (plain, line, or block): for selecting blocks of text</li>
<li><strong>Command-line</strong>: for running a command</li>
</ul>
<p>我们在此用到 insert 模式，在正常模式下按<code>i</code>进入 insert 模式，此时可以像其他编辑器一样对文件进行编辑，然后按<code>ESC</code>退回到正常模式</p>
<p>在正常模式下输入<code>:</code>会进入命令模式，最基础的命令有</p>
<ul>
<li><code>:q</code> quit (close window)</li>
<li><code>:w</code> save (“write”)</li>
<li><code>:wq</code> save and quit</li>
</ul>
<p>事实上 vim 还有许多十分强大的功能，感兴趣的同学可以自己了解</p>
<h2><a class="header" href="#tmux" id="tmux">tmux</a></h2>
<p>我们在使用 ssh 方法登录到服务器的时候是和服务器进行一次会话，而当我们从服务器断开的时候，会话结束，会话中的各个进程也会被终止，而 tmux 是用来解绑会话与打开的终端窗口的，可以让你启动的进程在断开连接之后继续运行</p>
<p>直接输入 tmux 命令会新建一个只有编号的 tmux 窗口，我们可以这样来新建命名的窗口</p>
<pre><code class="language-shell">$ tmux new -s &lt;session-name&gt;
</code></pre>
<p>在 tmux 窗口中，按下<code>Ctrl+b</code>，然后按<code>d</code>，可以从当前窗口分离，而窗口中的进程仍在后台运行</p>
<p>可以查看所有 tmux 会话</p>
<pre><code class="language-shell">$ tmux ls
# or
$ tmux list-session
</code></pre>
<p>然后使用<code>tmux attach</code>来重新接入会话</p>
<pre><code class="language-shell"># 使用会话编号
$ tmux attach -t 0

# 使用会话名称
$ tmux attach -t &lt;session-name&gt;
</code></pre>
<p>可以在会话中直接使用<code>Ctrl+d</code>或者输入<code>exit</code>来关闭，也可以在外部使用<code>tmux kill-session</code>命令杀死某个会话。</p>
<pre><code class="language-shell"># 使用会话编号
$ tmux kill-session -t 0

# 使用会话名称
$ tmux kill-session -t &lt;session-name&gt;
</code></pre>
<p>以上为 tmux 的最基础操作，更多可以参考<a href="http://www.ruanyifeng.com/blog/2019/10/tmux.html">这里</a></p>
<h1><a class="header" href="#docker" id="docker">Docker</a></h1>
<p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.org/">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 0.7 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a>。</p>
<img src="https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/media/docker-on-linux.png" width = "600" height = "400" alt="Docker 架构" align=center />
<p><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p>
<p>课件请见<a href="https://github.com/eesast/training2020/blob/master/basic_tool/docker">此处</a></p>
<h2><a class="header" href="#参考链接-1" id="参考链接-1">参考链接</a></h2>
<ul>
<li><a href="https://vuepress.mirror.docker-practice.com/">Docker — 从入门到实践</a></li>
<li><a href="https://docs.docker.com/">Docker官方文档</a></li>
</ul>
<h1><a class="header" href="#操作系统" id="操作系统">操作系统</a></h1>
<p>本讲主要介绍操作系统的相关知识，帮助大家快速建立操作系统的宏观认识。需要注意的是，操作系统涉及处理机管理、存储管理、文件系统、IO设备等多个方面，而本讲主要涉及处理机管理中的进程间通信、进程的同步与互斥、死锁等内容，较少涉及其它部分。以下为本讲大纲，详细课件参见<a href="https://github.com/eesast/training2020/blob/master/OS">仓库</a>。</p>
<h2><a class="header" href="#进程与线程" id="进程与线程">进程与线程</a></h2>
<h3><a class="header" href="#进程" id="进程">进程</a></h3>
<p>进程（Process）是具有独立功能的程序在某个数据集合上的一次运行活动，可以理解为操作系统执行的一个程序的实例。</p>
<p>三状态模型：运行、就绪、阻塞。</p>
<h3><a class="header" href="#线程" id="线程">线程</a></h3>
<p>线程（Thread）进一步减小了程序并发执行的时空开销，是轻量级进程。进程是资源分配的单位，线程是处理器调度的单位，同一个进程的多个线程共享资源。</p>
<p>用户级线程 vs 内核级线程</p>
<h3><a class="header" href="#处理器" id="处理器">处理器</a></h3>
<p>处理器状态：核心态（Kernel mode）与用户态（User mode），通过陷入（Trap）与修改程序状态字（PSW）互相切换。</p>
<p>CPU的一个核心上，同一时间片只能执行一个线程。操作系统在单核上实现并行的方式是通过处理器调度，使得各线程轮流执行，实现宏观并行。操作系统的调度需要陷入核心态，保存寄存器、堆栈，同时cache需要更新，因此有一定时间开销。</p>
<p>调度的时刻（抢先vs非抢先）：</p>
<ul>
<li>创建一个新进程后</li>
<li>一个进程运行完毕后</li>
<li>中断</li>
<li>一个进程被阻塞</li>
<li>时间片轮转</li>
</ul>
<p>对于计算密集型任务，频繁调度不划算；而对于IO密集型任务，调度是有较大收益的。</p>
<p>原语（primitive）：由若干条指令构成的 “原子操作（atomic operation）” 过程 ，作为一个整体而不可分割——要么全都完成 ，要么全都不做 要么全都不做 要么全都不做 。许多系统调用都是原语。原语可以避免因调度而被打断。</p>
<p>需要注意的是，C或其它编程语言的一条指令可能由多个汇编语句构成，而处理器执行汇编指令中都可能发生调度，因此同一条指令可能被打断，发生各种情况。</p>
<h3><a class="header" href="#linux--windows--posix-中的进程与线程" id="linux--windows--posix-中的进程与线程">Linux / Windows / POSIX 中的进程与线程</a></h3>
<p>Linux无线程概念，但可共享资源的进程可看作线程，相当于内核级线程。</p>
<p>Windows进程是惰性的，无实际作用，线程是调度单位，内核级线程。</p>
<p>POSIX未限定用户级/内核级线程。多线程编程接口标准pthread。</p>
<h2><a class="header" href="#进程同步与互斥" id="进程同步与互斥">进程同步与互斥</a></h2>
<ul>
<li>
<p>禁止中断</p>
<p>进入临界区前执行关闭中断指令，离开临界区后执行开中断。</p>
<p>简单但可靠性差，不适合多处理器。</p>
</li>
<li>
<p>严格轮转法
进程严格轮流进入临界区。
忙等待，效率较低，且可能在临界区外阻塞别的进程。</p>
</li>
<li>
<p>Petersen算法
可以正常工作的解决互斥问题的算法，仍使用锁。
忙等待，效率较低。</p>
</li>
<li>
<p>硬件指令方法
使用硬件提供不被打断的单条指令读写共享变量。
适用于任意数目进程，且较简单，但仍有忙等待。</p>
</li>
<li>
<p>信号量
使用原语访问信号量管理资源。
不必忙等，效率较高，但信号量的控制分布在整个程序中，正确性难以保证。</p>
</li>
<li>
<p>管程
信号量及其操作的高级语言封装。
效率同信号量一样，易于管理开发。</p>
</li>
<li>
<p>消息传递
用以实现分布式系统的同步、互斥。
支持分布式系统，但消息传递本身效率较低且不完全可靠。</p>
</li>
</ul>
<p>忙等待不但浪费CPU时间，还会出现优先级反转问题（priority inversion problem）。</p>
<h2><a class="header" href="#进程间通信" id="进程间通信">进程间通信</a></h2>
<h3><a class="header" href="#linux进程间通信" id="linux进程间通信">Linux进程间通信</a></h3>
<ul>
<li>信号</li>
<li>管道</li>
<li>消息队列</li>
<li>共享内存</li>
<li>套接字</li>
</ul>
<h3><a class="header" href="#windows进程间通信" id="windows进程间通信">Windows进程间通信</a></h3>
<ul>
<li>管道</li>
<li>共享内存</li>
<li>邮件槽</li>
<li>套接字</li>
</ul>
<h2><a class="header" href="#经典ipc问题" id="经典ipc问题">经典IPC问题</a></h2>
<ul>
<li>生产者-消费者问题</li>
<li>读者-写者问题</li>
<li>睡眠理发师问题</li>
<li>哲学家进餐问题</li>
</ul>
<h2><a class="header" href="#死锁" id="死锁">死锁</a></h2>
<p>死锁（Deadlock）是指系统中多个进程无限制地等待永远不会发生的条件。</p>
<p>死锁发生的必要条件：</p>
<ul>
<li>互斥</li>
<li>请求和保持</li>
<li>非剥夺</li>
<li>环路等待</li>
</ul>
<p>处理死锁问题的四种方法：</p>
<ul>
<li>鸵鸟算法</li>
<li>死锁预防
<ul>
<li>预先静态分配法</li>
<li>有序资源使用法</li>
</ul>
</li>
<li>死锁检测
<ul>
<li>资源分配图算法</li>
</ul>
</li>
<li>死锁避免
<ul>
<li>银行家算法</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#c概述" id="c概述">C#：概述</a></h4>
<p>C# 语法高度重视表达，但学习起来也很简单轻松。 任何熟悉 C、C++ 或 Java 的人都可以立即认出 C# 的大括号语法。 通常情况下，了解上述任何一种语言的开发者都可在短时间内就开始使用 C# 高效工作。 C# 语法简化了 C++ 的许多复杂操作，并提供强大功能，如可以为 null 的类型、枚举、委托、lambda 表达式和直接内存访问。 </p>
<p>作为面向对象的语言，C# 支持封装、继承和多态性这些概念。 所有变量和方法（包括作为应用程序入口点的 <code>Main</code> 方法）都封装在类定义中。 虽然类可能会直接继承一个父类，但可以实现任意数量的接口。 若要用方法重写父类中的虚方法，必须使用 <code>override</code> 关键字，以免发生意外重定义。 在 C# 中，结构就像是轻量级类，是可以实现接口但不支持继承的堆栈分配类型。</p>
<p>除了这些面向对象的基本原则，使用 C# 还可以通过以下多个创新语言构造更加轻松地开发软件组件：</p>
<ul>
<li>封装的方法签名（名为“<em>委托</em>”），可实现类型安全事件通知。</li>
<li>用作私有成员变量的访问器的属性。</li>
<li>在运行时提供有关类型的声明性元数据的特性。</li>
<li>内联的 XML 文档注释。</li>
<li>语言集成查询 (LINQ)，提供跨各种数据源的内置查询功能。</li>
</ul>
<p>C# 生成过程比 C 和 C++ 更简单，比 Java 更灵活。 没有单独的头文件，也不要求按特定顺序声明方法和类型。 C# 源文件可以定义任意数量的类、结构、接口和事件。</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/">微软官方文档</a></li>
</ul>
<h4><a class="header" href="#程序结构" id="程序结构">程序结构</a></h4>
<p>一个 C# 程序主要包括以下部分：</p>
<ul>
<li>命名空间声明（Namespace declaration）
<ul>
<li>Class 类声明
<ul>
<li>一个 Main 方法
<ul>
<li>语句（Statements）&amp; 表达式（Expressions）</li>
</ul>
</li>
<li>其他方法和属性</li>
</ul>
</li>
<li>其他类声明</li>
</ul>
</li>
<li>其他命名空间...</li>
</ul>
<pre><code class="language-c#">using System; // 在程序中包含System命名空间
namespace HelloWorldApplication // 声明命名空间
{
   class HelloWorld // 声明一个类
   {
      static void Main(string[] args) // 静态方法
      {
         /* 我的第一个 C# 程序*/
         HelloWorld n = new HelloWorld();
         Console.WriteLine(&quot;Hello World&quot;);  // System.Console.WriteLine
         /* 定义在 System 命名空间中的 Console 类的一个方法 */
         Console.ReadKey(); //等待一个按键的动作
      }
   }
}
</code></pre>
<h4><a class="header" href="#数据类型-1" id="数据类型-1">数据类型</a></h4>
<h5><a class="header" href="#值类型" id="值类型">值类型</a></h5>
<ul>
<li>bool，char，float(1.0F)，double(1.0D)，short(16)，int(32)，long(64)，uint...
<ul>
<li>byte 8位无符号整数</li>
<li>decimal：128位十进制整数/小数，有效位数28-29位(1.0M)</li>
<li>结构体(Struct)</li>
</ul>
</li>
<li>传参时进行值传递，拷贝副本</li>
<li>在栈空间上分配内存，不会给垃圾回收(GC)造成负担</li>
<li>不能派生其他子类，不能使用线程锁</li>
</ul>
<h5><a class="header" href="#引用类型" id="引用类型">引用类型</a></h5>
<ul>
<li>
<p>所有类型的基类object, 字符串string，数组Array，类class，接口interfac，委托delegate..</p>
</li>
<li>
<p>传参和直接赋值时进行引用传递，可以在函数内部改变其值</p>
<ul>
<li>
<p>string类较为特殊，string间赋值被重载为深复制</p>
<pre><code class="language-c#">string s1 = &quot;Hello, World!&quot;;
string s2 = s1;
s2 = &quot;See you!&quot;;
Console.WriteLine(s1); // &quot;Hello, World!&quot;
Console.WriteLine(s2); // &quot;See you!&quot;
</code></pre>
</li>
</ul>
</li>
<li>
<p>在堆空间上分配内存，并由GC机制进行内存管理</p>
</li>
<li>
<p>可以派生，可以使用线程锁等</p>
</li>
</ul>
<h5><a class="header" href="#指针类型" id="指针类型">指针类型</a></h5>
<ul>
<li>可以对方法添加unsafe关键字，并使用C，C++中的指针 int*等</li>
<li>在vs项目中设置允许使用不安全的代码</li>
<li>由于C#中的GC机制，一个变量（例如一个大数组）有可能在运行过程中被移动到内存中的其他位置，因此不建议使用指针类型(可以使用fixed关键字固定内存位置)</li>
<li>可以在unsafe环境中使用stackalloc分配栈内存，栈内存不受GC的影响</li>
</ul>
<h5><a class="header" href="#可空类型" id="可空类型">可空类型</a></h5>
<ul>
<li>定义变量时，在类型后添加?表示该变量可能为null：<code>double? num = null;</code></li>
<li>使用变量时，在变量后添加 ?? 表示若该变量为null，则使用 ?? 后的替换值
<ul>
<li><code>double num2 = num ?? 1.0</code></li>
</ul>
</li>
</ul>
<h5><a class="header" href="#类型转化" id="类型转化">类型转化</a></h5>
<ul>
<li>前加(类型名)，(int)</li>
<li>调用数据对象的ToString()，ToBoolean()，ToDouble()，Toint32()方法</li>
<li>调用System空间的Convert类的相应方法 <code>double a=Convert.ToDouble(1)</code></li>
<li>调用VarType.Parse()方法，参数必须为string，如 <code>Int.Parse(&quot;32&quot;)</code></li>
<li>使用as关键字，如果转换失败则返回null，只能用于引用类型间转化</li>
</ul>
<h5><a class="header" href="#类型判断" id="类型判断">类型判断</a></h5>
<ul>
<li>使用 is 关键字 <code>if( x is int)</code></li>
</ul>
<h5><a class="header" href="#装箱与拆箱" id="装箱与拆箱">装箱与拆箱</a></h5>
<ul>
<li>
<p>装箱：把值类型转换成引用类型；拆箱：把引用类型转换成值类型</p>
</li>
<li>
<pre><code class="language-c#">//装箱
int i = 1;
object obj = (object)i;
//拆箱
int j = (int)obj;
</code></pre>
</li>
<li>
<p>装箱与拆箱的过程会有性能损耗</p>
</li>
</ul>
<h4><a class="header" href="#基本语法" id="基本语法">基本语法</a></h4>
<h5><a class="header" href="#条件语句" id="条件语句">条件语句</a></h5>
<ul>
<li>if else：同C, C++</li>
<li>?运算符：同C, C++</li>
<li>switch case default：同C，C++，case需要添加break语句</li>
</ul>
<h5><a class="header" href="#循环语句" id="循环语句">循环语句</a></h5>
<ul>
<li>for( init; condition; end) 语句，同C, C++</li>
<li>while循环，do while循环，同C, C++</li>
<li>foreach语句
<ul>
<li>foreach(typename x in Array/Collection) //可迭代对象</li>
<li>逐一取出可迭代对象内的元素x，语句块内可以读取x的值，但不能改变x的值</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#string-字符串" id="string-字符串">String 字符串</a></h4>
<ul>
<li>String类的对象，用双引号表示字符串</li>
<li>使用String类的方法多种字符串操作
<ul>
<li>Compare, Concat, Contains, Copy, Ends/StartsWith, IndexOf, Insert, Replace, Remove, Split, Trim..</li>
</ul>
</li>
<li>使用ToCharList方法转换为字符数组</li>
<li>使用@前缀表示转义字符串：<code>@&quot;C:\Windows&quot;</code></li>
<li>使用$前缀进行字符串内插：</li>
</ul>
<pre><code class="language-c#">string name = &quot;Mark&quot;;
var date = DateTime.Now;
Console.WriteLine($&quot;Hello, {name}! Today is {date.DayOfWeek}.&quot;);
// Hello, Mark! Today is Wednesday.
</code></pre>
<ul>
<li>也可使用Format方法插入数值，但较为繁琐</li>
</ul>
<p><code>Console.WriteLine(&quot;Hello, {0}! Today is {1}.&quot;, name, date.DayOfWeek);</code></p>
<h4><a class="header" href="#array-数组" id="array-数组">Array 数组</a></h4>
<ul>
<li><code>double[] a = new double[10];</code> <code>double[] b = a;//a和b指向同一内存位置</code> </li>
<li><code>double[] a = { 2340.0, 4523.69, 3421.0};</code></li>
<li>数组作为参数传入时，函数体内可修改数组元素的值 </li>
</ul>
<h5><a class="header" href="#多维数组" id="多维数组">多维数组</a></h5>
<ul>
<li>
<p>类似矩阵的数据结构</p>
<pre><code class="language-c#">int [,] a = new int [2,3] 
{
 {0, 1, 2} ,
 {3, 4, 5} ,
};
</code></pre>
</li>
<li>
<p>访问元素：<code>int b = a[1,2] \\5</code></p>
</li>
<li>
<p>使用Rank属性获取多维数组的维数，使用GetLength(d)来获取第d维的长度</p>
</li>
<li>
<p>foreach循环会遍历每个元素</p>
</li>
</ul>
<h5><a class="header" href="#交错数组" id="交错数组">交错数组</a></h5>
<ul>
<li>类似C，C++中的多维数组，本质是“元素是数组的数组&quot;</li>
<li><code>int[][] a = new int[2][]{new int[]{92,93,94},new int[]{85,66,87,88}};</code></li>
<li>获取a的Rank属性，得到结果为1，foreach循环只会遍历各个数组</li>
</ul>
<h4><a class="header" href="#struct-结构体" id="struct-结构体">Struct 结构体</a></h4>
<ul>
<li>可以定义字段，属性(区别一会儿再说)，方法，构造函数，不能定义析构函数</li>
<li>可以声明静态成员</li>
<li>构造函数必须带参数，且在构造函数中必须为每个字段赋值</li>
<li>作为参数时是值传递，储存在栈空间中，所需空间较小</li>
<li>不能继承和派生</li>
</ul>
<pre><code class="language-c#">struct Books
{
   private string title;
   private string author;
   public Books(string t, string a)
   {
   		title = t;
        author = a;
   }
}; 
</code></pre>
<h4><a class="header" href="#enum-枚举" id="enum-枚举">Enum 枚举</a></h4>
<ul>
<li>同C, C++，默认为Public，可以显式指定枚举对应的值</li>
</ul>
<pre><code class="language-c#">enum Numbers
{
    One,
	Three = 3,
    Four // 从上一项的值+1
}
static void Main()
{
	Numbers num = Numbers.Three;
	Console.WriteLine(num); // &quot;Three&quot;
	int one = 1;
	num = (Numbers) one; // Enum和int可以强制类型转换
	Console.WriteLine(Convert.ToString(num)); // 使用Convert获取枚举字符串
	string four = &quot;Four&quot;;
	num = (Numbers)Enum.Parse(typeof(Numbers), four); //由字符串转换为枚举
	Console.WriteLine((int)num);
}
</code></pre>
<h4><a class="header" href="#class-类" id="class-类">Class 类</a></h4>
<ul>
<li>基本定义同C，C++，有构造和析构函数(不支持构造函数的简洁写法)</li>
<li>作为参数时是引用传递</li>
<li>静态变量和静态方法：该类的各个对象共享同一个变量，而<strong>静态方法只能使用静态变量，调用静态方法</strong>
<ul>
<li>main方法是静态方法，故Program类中的全局变量应该设为静态变量</li>
<li>可以使用类名.方法名，不实例化类的对象直接调用静态方法</li>
</ul>
</li>
</ul>
<h5><a class="header" href="#方法" id="方法">方法</a></h5>
<ul>
<li>在类中定义方法，每一个 C# 程序至少有一个带有 Main 方法的类。</li>
</ul>
<pre><code class="language-c#">   public int Max(int ref num1, int ref num2)
   {
       return num1 &gt; num2 ? num1 : num2;
   }
</code></pre>
<ul>
<li>
<p>使用非静态方法时必须先实例化类的对象，如在Program类中声明了main函数和以上Max函数，则在main函数中调用Max函数时，需先声明Program对象：<code>Program n = new Program();</code>，再调用相应的方法：<code>n.Max(ref a, ref b)</code></p>
</li>
<li>
<p>参数传递：</p>
<ul>
<li>值传递：拷贝值型变量的副本</li>
<li>引用参数：在方法的参数列表和调用方法时均增加<strong>ref</strong>关键字</li>
<li>输出参数：在方法的参数列表和调用方法时均增加<strong>out</strong>关键字, out参数必须在方法内赋值，且不能在赋值前被使用</li>
</ul>
</li>
</ul>
<h5><a class="header" href="#访问控制" id="访问控制">访问控制</a></h5>
<ul>
<li>public, private, protected(对该类对象及其子类对象可以访问)</li>
<li>如果不声明，则默认为private</li>
</ul>
<h5><a class="header" href="#继承与派生" id="继承与派生">继承与派生</a></h5>
<ul>
<li>继承和派生与C，C++类似，继承后子类可以访问父类中public和protected的字段，属性和方法</li>
</ul>
<table><thead><tr><th align="center"></th><th align="center">实方法</th><th align="center">虚方法</th><th align="center">抽象方法</th></tr></thead><tbody>
<tr><td align="center">修饰符</td><td align="center">/</td><td align="center">virtual</td><td align="center">abstract</td></tr>
<tr><td align="center">父类要求</td><td align="center">/</td><td align="center">/</td><td align="center">有抽象方法的类也为抽象类</td></tr>
<tr><td align="center">父类实现</td><td align="center">/</td><td align="center">父类必须给出虚方法的实现</td><td align="center">父类可以只声明抽象方法</td></tr>
<tr><td align="center">子类实现</td><td align="center">子类可以覆盖实方法</td><td align="center">子类可以重载或覆盖虚方法</td><td align="center">子类必须重载虚方法</td></tr>
<tr><td align="center">重载(override)</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr>
<tr><td align="center">覆盖(new)</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr>
<tr><td align="center">基类调用(base)</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr>
<tr><td align="center">密封类(sealed)</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr>
</tbody></table>
<ul>
<li>覆盖与重载的区别：覆盖后子类的实例可以调用父类被覆盖的方法(强制类型转换)，而重载后则不可以，对于虚方法一般使用重载</li>
<li>声明密封类：此类不能被继承</li>
</ul>
<pre><code class="language-c#">using System;

namespace CSharpLearning
{
    abstract class Animal // 有抽象方法的类必须是抽象类
    {
        public Animal(){};
        public void Move() // 实方法
        {
            Console.WriteLine(&quot;调用了Animal类的Move方法&quot;);
        }
        public virtual void Attack() // 虚方法，必须给出实现
        {
            Console.WriteLine(&quot;调用了Animal类的Attack方法&quot;);
        }
        public abstract void Name(); // 抽象方法，可以只声明，不实现

    }

    sealed class Cat : Animal // 密封类，不能派生，继承了Animal类
    {
        public override void Name() // 若不重载抽象方法则会报错
        {
            Console.WriteLine(&quot;调用了Cat类的Name方法&quot;);
        }

        public override void Attack() // 可以重载父类的虚方法，也可不重载，还可用new覆盖父类的虚方法
        {
            Console.WriteLine(&quot;调用了Cat类的Attack方法&quot;);
        }

        public new void Move() // 使用new覆盖父类的实方法
        {
            base.Move(); // 使用base关键字调用父类的同名方法
            Console.WriteLine(&quot;调用了Cat类的Move方法&quot;);
        }

    }
    class Program
    {
        static void Main(string[] args)
        {
            // Animal animal = new Animal(); 报错：无法创建抽象类Animal的实例
            Cat cat=new Cat();
            cat.Name(); // 调用了Cat类的Name方法
            cat.Move(); // 调用了Animal类的Move方法/n 调用了Cat类的Move方法
            ((Animal)cat).Move(); // 调用了Animal类的Move方法
            ((Animal)cat).Attack(); // 调用了Cat类的Attack方法
            Console.ReadKey();
        }
    }
}
</code></pre>
<h5><a class="header" href="#字段与属性" id="字段与属性">字段与属性</a></h5>
<ul>
<li><a href="https://www.cnblogs.com/doThing/p/properties-in-csharp.html">更多参考资料</a></li>
<li>字段又称“成员变量”，一般在类的内部做数据交互使用，命名时通常首字母小写</li>
<li>属性是外界访问私有字段的入口，负责指定相应字段的读、写方式，命名与对应字段相同且首字母大写</li>
<li>声明属性时，首先声明相应的私有字段，然后指定属性的get和set访问器</li>
</ul>
<pre><code class="language-c#">class Person
{
    private int age;
	public int Age
	{
		get { return age; }
    	set { age = value &gt; 120 ? 120 : value; }
        // 此处value为关键字，代表用户所赋的值
	}
}
</code></pre>
<ul>
<li>在C# 7.0之后也可用类似lambda表达式的方法设置属性</li>
</ul>
<pre><code class="language-c#">class Person
{
    private int age;
	public int Age { get =&gt; age; set =&gt; age = value &gt; 120 ? 120 : value; }
    // 注意set语句中仍需对age赋值
    // 如果只实现get访问器，则可以进一步简化为 public int Age =&gt; age;
}
</code></pre>
<ul>
<li>使用属性对应字段的值时，直接对属性读取或赋值：</li>
</ul>
<pre><code class="language-c#">Person person = new Person();
person.Age = 20;
Console.WriteLine(person.Age);
</code></pre>
<ul>
<li>
<p>若属性访问器中<strong>不需要任何其他逻辑</strong>时，我们可以使用自动实现的属性，不需要声明相应字段</p>
<p><code>public int Age { get; set; }</code></p>
</li>
<li>
<p>此时也可进行初始化<code>public string Name { get; set; } = &quot;Jane&quot;;</code></p>
</li>
<li>
<p>若去除set访问器，则属性变为只读的，必须为其指定初始值</p>
<p><code>public string Name { get; } = &quot;Jane&quot;;</code></p>
</li>
</ul>
<h4><a class="header" href="#运算符重载" id="运算符重载">运算符重载</a></h4>
<ul>
<li>基本与C，C++一致，使用operator关键字且应声明为static方法</li>
</ul>
<pre><code class="language-c#">public static Student operator +(Student s1, Student s2)
{
	return new Student(s1.age + s2.age, s1.name + &quot; And &quot; + s2.name);
}
</code></pre>
<ul>
<li>重载 == 操作符后也必须重载 != 操作符</li>
<li>重载 + 操作符后 += 操作符也自动被重载，- , * , / 等类似</li>
<li>使用Implict/Explict关键字重载隐式/显式类型转换运算符
<ul>
<li><code>public static implict operator A(B b)</code> 类型B到类型A的隐式转换</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#interface-接口" id="interface-接口">Interface 接口</a></h4>
<ul>
<li>接口使用 <strong>interface</strong> 关键字声明，它与类的声明类似。接口声明默认是 public 的</li>
<li>抽象类在某种程度上与接口类似，但是，抽象类大多用于只有少数方法由基类声明而由派生类实现时，接口则指定的其派生类应遵循的标准</li>
<li>接口通常以大写 I 开头命名，接口的定义与类的定义相似(interface关键字)，其中方法默认为public，接口内也可有属性的声明，但不能有字段</li>
<li>C#中不允许继承多个类，但可以继承多个接口</li>
<li>接口可以继承其他接口，而实现该接口的类应该实现所有接口的方法和属性</li>
</ul>
<pre><code class="language-c#">interface IPerson
{
　　string Name { get; set; }`
　　void Show(string name);
}

interface IStudent //也可继承IPerson接口，则Student类只需继承IStudent接口
{
　　string Id { get; set; }`
　　void Show(string id); //若继承IPerson接口，则应加new修饰符覆盖同名方法
}

class Student: IPerson, IStudent //多继承
{
　　public string Name { get; set; }`
　　public string Id { get; set; }`
      
　　void IPerson.Show(string name) //分别实现不同接口的同名方法
　　{
    　　Console.WriteLine(&quot;姓名为{0}&quot;, name);
　　}
    
　　void IStudent.Show(string id) //如果指定实现接口的函数，则可以不使用访问控制
　　{
    　　Console.WriteLine(&quot;学号为{0}&quot;, id);
　　}
    
	//public void Show(string id) //如果统一实现，则必须指定访问控制符
    	//{
        //    Console.WriteLine(&quot;姓名为{name},学号为{id}&quot;);
        //}
}

class Program
{
　　static void Main()
　　{
    　　Student s = new Student();
    　　Console.WriteLine(&quot;输入姓名&quot;);
    　　s.Name = Console.ReadLine();
    　　Console.WriteLine(&quot;输入学号&quot;);
    　　s.Id = Console.ReadLine();
    　　IPerson per = s;
    　　per.Show(s.Name);
    　　IStudent stu = s;
    　　stu.Show(s.Id);
　　}
}
</code></pre>
<ul>
<li>函数可以使用接口作为参数，在传参时传入不同实现该接口的类的实例</li>
</ul>
<h4><a class="header" href="#exception-异常处理" id="exception-异常处理">Exception 异常处理</a></h4>
<ul>
<li>类似C++的 try - throw - catch - finally结构</li>
<li>一个try块至少对应一个catch块或1个finally块</li>
<li>只会进入从上向下的第一个匹配的代码块，若当前函数中没有匹配的catch块则会搜索外层函数</li>
</ul>
<pre><code class="language-c#">static int GetInt(int[] array, int index)
{
	try
	{
		return array[index];
	}
	catch (System.IndexOutOfRangeException ex)  //下标越界的更具体原因在于传递了越界的参数index
	{
		Console.WriteLine(ex.Message);
        // 创建更精确的异常并抛出给外层函数
		throw new ArgumentException(&quot;index parameter is out of range.&quot;, &quot;index&quot;, ex);
    }
}
static void Main()
{
    try
    {
        int[] a = {1, 2, 3, 4, 5};
        GetInt(a, 5);
    }
    catch (ArgumentException ex)
    {
        Console.WriteLine(ex.Message);
    }
    catch (Exception)
    {
        Console.WriteLine(&quot;发生未知错误!&quot;);
    }
    finally //一般用于释放资源
    {
        Console.WriteLine(&quot;Done!&quot;);
    }
}
</code></pre>
<h4><a class="header" href="#delegate-委托" id="delegate-委托">Delegate 委托</a></h4>
<ul>
<li>类似于C, C++的函数指针，可用于引用任何返回值和参数列表相同的方法</li>
<li>delegate void printString(string s);`</li>
<li>声明委托后，使用new创建委托对象，并且传入要引用的函数名作为参数
<ul>
<li><code>printString ps1 = new printString(WriteToScreen);</code></li>
</ul>
</li>
<li>此后可以使用委托对象调用对应</li>
</ul>
<h5><a class="header" href="#多播委托" id="多播委托">多播委托</a></h5>
<ul>
<li>作用于参数和返回值相同的委托对象直接</li>
<li>委托类型重载了 + - 运算符，可用于依次执行一系列任务，再返回值</li>
</ul>
<pre><code class="language-c#">using System;
namespace Program
{
	delegate int NumberChanger(int n); // 委托可以直接在命名空间内声明
    class TestDelegate
    {
        public static int Num { get; set; } = 10;
        public static int AddNum(int p)
        {
            Num += p;
            return Num;
        }

        public static int MulNum(int q)
        {
            Num *= q;
            return Num;
        }
        static void Main(string[] args)
        {
            NumChanger fc1 = new NumChanger(AddNum);
            NumChanger fc2 = new NumChanger(MulNum);
            NumChanger fc = fc2 + fc1;
            Console.WriteLine(fc(5)); // 75 = (10 * 5) + 5
        }
    }
}
</code></pre>
<ul>
<li>委托可以接受匿名函数作为参数</li>
</ul>
<p><code>NumChanger fc1 = delegate(int p) { Num += p; return p;};</code></p>
<ul>
<li>也可以接受一个<strong>lambda表达式</strong>作为参数：</li>
</ul>
<p><code>NumChanger fc1 = (int p) =&gt;  { Num += p; return p;};</code> </p>
<h5><a class="header" href="#lambda表达式" id="lambda表达式">lambda表达式</a></h5>
<ul>
<li>表达式lambda，自动返回表达式的值
<ul>
<li>(int x, int y) =&gt; x * y 或省略类型声明 (x, y) =&gt; x * y</li>
<li>只有1个参数时可省略左侧的括号 x =&gt; x * x * x</li>
</ul>
</li>
<li>语句lambda
<ul>
<li>(int x, int y) =&gt; { return x * y; }</li>
<li>右侧用大括号扩起，内部可以有多条语句(不宜过多)，也可没有返回值</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#generic-泛型" id="generic-泛型">Generic 泛型</a></h4>
<ul>
<li>类似C++ 的模板，可以兼容不同的数据类型，但限制更多</li>
<li>泛型类：<code>class MyArray&lt;T&gt;</code></li>
<li>泛型方法： <code>static void Swap&lt;T&gt;(ref T x, ref T y)</code></li>
<li>泛型委托：<code>delegate T NumberChanger&lt;T&gt;(T n);</code></li>
<li>泛型接口：<code>interface IDictionary&lt;K, V&gt;</code></li>
<li>继承泛型类或接口时待定类型只能不变或增多</li>
</ul>
<h5><a class="header" href="#泛型的类型约束" id="泛型的类型约束">泛型的类型约束</a></h5>
<ul>
<li>
<p>声明泛型时可以给泛型添加一定的约束：<code>class MyArray&lt;T&gt; where T : struct</code></p>
</li>
<li>
<p>where T : struct ：T必须为(不可为空的)值类型</p>
</li>
<li>
<p>where T : class ：T必须为(不可为空的)引用类型</p>
</li>
<li>
<p>where T : notnull ：T必须为不可为空的类型</p>
</li>
<li>
<p>where T : new() ：T必须具有无参数的构造函数，不能与struct合用</p>
</li>
<li>
<p>where T : &lt;interface name&gt; ：T必须实现指定的接口</p>
</li>
<li>
<p>where T : &lt;base class name&gt; ：T必须为指定类或其派生类</p>
</li>
<li>
<p>多个限制并用：用逗号分隔</p>
</li>
<li>
<p>约束多个参数：</p>
<pre><code class="language-c#">class Base { }
class Test&lt;T, U&gt;
    where U : struct
    where T : Base, new()
</code></pre>
</li>
</ul>
<h4><a class="header" href="#collections-集合" id="collections-集合">Collections 集合</a></h4>
<ul>
<li>包含了一系列基本数据结构的命名空间</li>
<li>ArrayList, SortedList, Hashtable, Stack, Queue..
<ul>
<li>一般包含Add, Clear, Remove等方法</li>
</ul>
</li>
<li>包含一些基本的接口，如 IComparer, IEnumerator(迭代), IList(按索引访问)</li>
<li>并未指定成员的数据类型，因此全部成员都被转换为object类</li>
<li>对于值类型，使用Collections意味着频繁的装箱和拆箱，性能不佳</li>
</ul>
<h5><a class="header" href="#collectionsgeneric" id="collectionsgeneric">Collections.Generic</a></h5>
<ul>
<li>利用泛型值类数据类型的数据结构，拥有更好的类型安全性和性能</li>
<li>Tuple&lt;T1, T2, T3, ...&gt; ，使用.Item1, .Item2来访问，类似C++的pair
<ul>
<li>使用C# 7.0的新特性<strong>元组</strong>实现此功能</li>
<li>(1, 2)； (&quot;one&quot;, &quot;two&quot;)，...</li>
<li>可以为每个元组的元素起别名：（x : 1, y : 2)</li>
<li>元组支持直接赋值和比较</li>
</ul>
</li>
<li>List&lt;T&gt;  类似C++ vector</li>
<li>Dictionary&lt;T1, T2&gt;</li>
<li>Queue&lt;T&gt;， Stack&lt;T&gt;</li>
<li>HashSet&lt;T&gt;</li>
</ul>
<h5><a class="header" href="#常用库函数介绍补充" id="常用库函数介绍补充">常用库函数介绍(补充)</a></h5>
<ul>
<li>
<p>System.IO 包含对一系列系统调用的支持，比如各种文件操作</p>
<ul>
<li>FileStream</li>
<li>StreamReader 与 StreamWriter 进行文本文件读写</li>
<li>BinaryReader 和 BinaryWriter 类用于二进制文件的读写</li>
<li>DirectoryInfo 类和 FileInfo 类用于进行windows文件系统的操作</li>
</ul>
</li>
<li>
<p>System.Linq 使用一定格式的语句查询和筛选可迭代对象</p>
</li>
<li>
<p>System.Text 包含一系列编解码相关的功能</p>
</li>
<li>
<p>System.Text.RegularExpressions; 包含正则表达式的基类Regex</p>
</li>
<li>
<p>System.Threading 提供启用多线程的类和接口.</p>
</li>
<li>
<p><strong>事件、异步、多线程... 未完待续</strong></p>
</li>
</ul>
<h1><a class="header" href="#c课程2事件异步多线程" id="c课程2事件异步多线程">C#课程2（事件、异步、多线程）</a></h1>
<ul>
<li><a href="CSharp/CS-Learning2-MultiThread.html#c%E8%AF%BE%E7%A8%8B2%E4%BA%8B%E4%BB%B6%E5%BC%82%E6%AD%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B">C#课程2（事件、异步、多线程）</a>
<ul>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E4%B8%80%E4%BA%8B%E4%BB%B6event">一、事件（event）</a></li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E4%BA%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B">二、多线程</a>
<ul>
<li><a href="CSharp/CS-Learning2-MultiThread.html#1-%E7%AE%80%E4%BB%8B">1. 简介</a></li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2. 常用方法</a></li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#3-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7">3. 常用属性</a></li>
</ul>
</li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E4%B8%89%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">三、异步编程</a>
<ul>
<li><a href="CSharp/CS-Learning2-MultiThread.html#1-%E7%AE%80%E4%BB%8B-1">1. 简介</a></li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#2-task%E4%BB%8B%E7%BB%8D">2. Task介绍</a></li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#3-async-%E5%92%8C-await">3. async 和 await</a></li>
</ul>
</li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E5%9B%9B%E9%94%81">四、锁</a>
<ul>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E8%AF%BB%E5%86%99%E9%94%81">读写锁</a></li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F">死锁的产生</a></li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98">哲学家就餐问题</a></li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6">死锁产生的条件</a></li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3">死锁的解决</a></li>
</ul>
</li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E4%BA%94%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">五、原子操作</a></li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E5%85%ADc-%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88">六、C# 并发集合</a></li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E4%B8%83c%E5%AE%9A%E6%97%B6%E5%99%A8">七、C#定时器</a>
<ul>
<li><a href="CSharp/CS-Learning2-MultiThread.html#systemthreadingtimer">System.Threading.Timer</a></li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#systemtimerstimer">System.Timers.Timer</a></li>
</ul>
</li>
<li><a href="CSharp/CS-Learning2-MultiThread.html#%E5%85%ABc-%E7%BA%BF%E7%A8%8B%E6%B1%A0">八、C# 线程池</a></li>
</ul>
</li>
</ul>
<hr />
<h2><a class="header" href="#一事件event" id="一事件event">一、事件（event）</a></h2>
<p>通俗来讲，事件是一种广播机制</p>
<p>比如某个组件订阅了一个事件，那么在这个事件被触发的时候组件会收到通知。</p>
<p>例：小明家里有一部电话，有一个正在烧水的热水壶，电话响了（这是一个event）就会触发小明接电话（这是一个方法）这个动作。（*注：这部分代码参考Event.cs）</p>
<p>事件可以实现底层程序集调用高层程序集的方法。并且在调用的时候可以向高层程序集的方法传入参数。</p>
<p>例：我写了一个库，这个库给出一个Read的事件，这个事件会在控制台输入字符串的时候被调用。（*注：这部分代码参考Event2.cs）</p>
<hr />
<h2><a class="header" href="#二多线程" id="二多线程">二、多线程</a></h2>
<h3><a class="header" href="#1-简介" id="1-简介">1. 简介</a></h3>
<p>进程是操作系统执行程序的基本单位</p>
<p>一个进程拥有多个线程，这些线程之间资源共享。</p>
<p>使用线程进行并发式编程。</p>
<p>C#提供了完整的多线程库</p>
<h3><a class="header" href="#2-常用方法" id="2-常用方法">2. 常用方法</a></h3>
<p>以下代码显示了如何创建一个线程</p>
<pre><code class="language-csharp">using System.Threading; // 包含多线程需要的库

public static void Function() // 一个需要被线程调用的函数
{
    Console.WriteLine(&quot;Function !&quot;);
}

Thread t = new Thread(Function); // 用Function函数初始化线程
</code></pre>
<p>上面的代码并没有让线程运行，如果要让线程开始运行，需要调用 Start() 方法。</p>
<pre><code class="language-csharp">t.Start();
</code></pre>
<p>如果Function的定义修改为如下</p>
<pre><code class="language-csharp">public static void Function(string str);
</code></pre>
<p>那么在Start()方法中就要传入参数。</p>
<pre><code class="language-csharp">t.Start(&quot;Hello World&quot;);
</code></pre>
<p>使用Sleep()方法可以暂停线程一段时间，单位为毫秒。</p>
<pre><code class="language-csharp">Thread.Sleep(1000) // 线程停顿1秒
</code></pre>
<p>使用Join()方法可以阻塞当前线程，等待某一个线程执行完毕后再进行后面的任务。比如下面的代码，展示了Join()方法的阻塞作用</p>
<pre><code class="language-csharp">public static void Function()
{
    for (int i = 0; i &lt; 10; i++)
    {
        Thread.Sleep(200);
        Console.WriteLine(&quot;Function !&quot;);
    }
}
public static void Run()
{
    Thread t = new Thread(Function);
    t.Start();
    Thread.Sleep(500);
    t.Join(); // 这里阻塞了Run()方法所在线程，等待t执行完毕
    Console.WriteLine(&quot;Finish !&quot;);
}
</code></pre>
<p>注意！非常不建议使用Suspend()、Abort()等方法在线程外部暂停或终止一个线程。</p>
<h3><a class="header" href="#3-常用属性" id="3-常用属性">3. 常用属性</a></h3>
<ul>
<li>IsBackground 属性，显示一个线程是否为后台线程。</li>
<li>如果一个线程为后台线程，那么程序不会等待这个线程执行完毕；如果一个线程是前台线程，程序会等待线程执行完毕再退出。</li>
<li>IsAlive 属性，显示一个线程是否正在运行。</li>
<li>IsThreadPoolThread 属性，显示线程是否属于托管线程池。</li>
</ul>
<p>下面的代码展示了如何控制一个线程是否为后台线程</p>
<pre><code class="language-csharp">new Thread(() =&gt;
{
    for (int i = 0; i &lt; 10; i++)
    {
        Thread.Sleep(300);
        Console.WriteLine(&quot;Thread1 : &quot; + i);
    }
})
{ IsBackground = true }.Start();
new Thread(() =&gt;
{
for (int i = 0; i &lt; 6; i++)
{
    Thread.Sleep(300);
    Console.WriteLine(&quot;Thread2 : &quot; + i);
}
})
{ IsBackground = false }.Start();
</code></pre>
<hr />
<h2><a class="header" href="#三异步编程" id="三异步编程">三、异步编程</a></h2>
<h3><a class="header" href="#1-简介-1" id="1-简介-1">1. 简介</a></h3>
<p>C# 引入了async和await关键字后，异步编程变得十分方便</p>
<p>实际上异步编程也是多线程的一种，只不过不需要手动创建线程，线程从线程池中被创建</p>
<p>例：比如我们在处理UI和按钮单击时，需要运行一个长时间运行的方法，比如读取一个大文件，如果采用同步编程，整个程序必须等待这个任务完成才能执行其他任务。</p>
<h3><a class="header" href="#2-task介绍" id="2-task介绍">2. Task介绍</a></h3>
<p>使用Task可以很方便地创建一个任务并运行，下面的代码展示了如何创建任务。</p>
<pre><code class="language-csharp">Task.Run(Method1);
</code></pre>
<p>还可以采用其他形式创建任务</p>
<pre><code class="language-csharp">Task task = new Task(Method1);
task.Start();
</code></pre>
<p>还可以采用Factory创建并运行任务</p>
<pre><code class="language-csharp">Task.Factory.StartNew(Method1);
</code></pre>
<p>Task的生命周期：Task.Status</p>
<p>Task的生命周期有如下几种状态：</p>
<ul>
<li>Created : 已经被创建但还未开始运行</li>
<li>Running : 正在运行</li>
<li>RanToCompletion : 执行完毕</li>
</ul>
<p>下面的代码展示了Task的生命周期：</p>
<pre><code class="language-csharp">public static void Method1()
{
    for (int i = 0; i &lt; 5; i++)
    {
        Thread.Sleep(200);
        Console.WriteLine(&quot;Method1 : &quot; + i);
    }
}
public static void Run()
{
    Task task = new Task(Method1);
    Console.WriteLine(task.Status);
    task.Start();
    for (int i = 0; i &lt; 7; i++)
    {
        Thread.Sleep(200);
        Console.WriteLine(task.Status);
    }
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-csharp">Created
Running
Method1 : 0
Method1 : 1
Running
Running
Method1 : 2
Method1 : 3
Running
Running
Method1 : 4
RanToCompletion
RanToCompletion
</code></pre>
<p>Task的任务控制，可以控制多个Task的执行顺序</p>
<p>Task.Wait()方法等待任务执行完毕</p>
<pre><code class="language-csharp">Task task1 = new Task(Method1);
task1.Start();
task.Wait(); // 等待任务执行完毕
Console.WriteLine(&quot;task Finish&quot;);
</code></pre>
<p>Task.WaitAll()等待所有任务执行完毕</p>
<pre><code class="language-csharp">Task task1 = new Task(Method1);
task1.Start();
Task task2 = new Task(Method2);
task2.Start();
Task.WaitAll(task1, task2);
Console.WriteLine(&quot;task Finish&quot;);
</code></pre>
<p>Task.WaitAny() 等待任一任务执行完毕</p>
<pre><code class="language-csharp">Task task1 = new Task(Method1);
task1.Start();
Task task2 = new Task(Method2);
task2.Start();
Task.WaitAny(task1, task2);
Console.WriteLine(&quot;task Finish&quot;);
</code></pre>
<p>Task 返回值 Task&lt; TResult &gt;</p>
<p>任何一个异步Task都可以返回一个值，下面的代码展示了如何获取Task的返回值。</p>
<pre><code class="language-csharp">public static string MethodReturn()
{
    for (int i = 0; i &lt; 5; i++)
    {
        Thread.Sleep(200);
        Console.WriteLine(&quot;MethodReturn : &quot; + i);
    }
    return &quot;MethodReturn finish&quot;;
}
Task&lt;string&gt; taskReturn = new Task&lt;string&gt;(MethodReturn);
taskReturn.Start();
Console.WriteLine(&quot;Task finish with : &quot; + taskReturn.Result);
</code></pre>
<p>可以看到只需要调用Task.Result就可以获取Task的返回值，并且在尝试获得Task的返回值时会自动阻塞当前线程，直到Task结束。</p>
<h3><a class="header" href="#3-async-和-await" id="3-async-和-await">3. async 和 await</a></h3>
<p>await 和字面意思一样，就是等待，下面的代码展示了等待一个任务执行完毕</p>
<pre><code class="language-csharp">public static async void Run()
{
    await Task.Run(Method1);
    Console.WriteLine(&quot;Task1 finish &quot;);
}
</code></pre>
<p>await 更大的用处是等待一个有返回值的Task，如下代码所示：</p>
<pre><code class="language-csharp">public static async void Run()
{
    Task&lt;string&gt; task = new Task&lt;string&gt;(MethodReturn);
    task.Start();
    Console.WriteLine(&quot;Task1 finish with : &quot; + await task);
}
</code></pre>
<p>async 的意思也和字面意思完全一样，就是表明一个方法是异步方法，下面展示了一个异步方法：</p>
<pre><code class="language-csharp">public static async void TestAsync()
{
    await Task.Run(
        () =&gt;
        {
            for (int i = 0; i &lt; 5; i++)
            {
                Thread.Sleep(200);
                Console.WriteLine(&quot;TestAsync : &quot; + i);
            }
        });
}
public static async void Run()
{
    TestAsync();
    Console.WriteLine(&quot;Task1 finish  &quot;);
}
</code></pre>
<p>可以注意到凡是方法体里出现了await关键字的，方法定义必然要出现async关键字，这是显然的，因为凡是有await关键字的方法必为异步方法。</p>
<p>需要注意的是如果一个被async修饰的方法里面没有await关键字的话，那么这个方法和同步方法没有区别。</p>
<p>一个async方法里面的异步操作仅出现在await关键字之后。</p>
<pre><code class="language-csharp">public static async void TestAsync()
{
    for (int i = 0; i &lt; 3; i++)
    {
        Thread.Sleep(200);
        Console.WriteLine(&quot;Sync : &quot; + i);
    }
    await Task.Run(
        () =&gt;
        {
            for (int i = 0; i &lt; 5; i++)
            {
                Thread.Sleep(200);
                Console.WriteLine(&quot;TestAsync : &quot; + i);
            }
        });
}
public static async void Run()
{
    TestAsync();
    Console.WriteLine(&quot;Task1 finish  &quot;);
}
</code></pre>
<p>因为async方法为异步方法，所以调用async方法的时候常常也使用await。</p>
<pre><code class="language-csharp">public static async Task&lt;string&gt; AsyncReturn()
{
    await Task.Run(
        () =&gt;
        {
            for (int i = 0; i &lt; 5; i++)
            {
                Thread.Sleep(200);
                Console.WriteLine(&quot;AsyncReturn : &quot; + i);
            }
        });
    return &quot;AsyncReturn finish&quot;;
}
public static async void Run()
{
    var str = await AsyncReturn();
    Console.WriteLine(&quot;Task1 finish with : &quot; + str);
}
</code></pre>
<p>注意：async方法的返回值只能为void、Task、Task&lt; TResult &gt;，不能为其他</p>
<hr />
<h2><a class="header" href="#四锁" id="四锁">四、锁</a></h2>
<p>多线程编程过程中常常会出现多个线程同时访问一个资源的情况，这个时候就需要用到锁，把共享的资源锁起来。</p>
<p>一个不使用锁的例子：</p>
<pre><code class="language-csharp">int num = 0;
Task.Run(
() =&gt;
{
    for (int i = 0; i &lt; 1000; i++)
    {
        num++;
    }
    Console.WriteLine(&quot;Thread 1 : &quot; + num);
}
);
Task.Run(
() =&gt;
{
    for (int i = 0; i &lt; 1000; i++)
    {
        num++;
    }
    Console.WriteLine(&quot;Thread 2 : &quot; + num);
}
);
</code></pre>
<p>锁的使用非常简单，只需要使用 lock 关键字就可以锁住一个对象，一个对象同时只允许一个线程访问，其他线程在这个期间会被阻塞。</p>
<pre><code class="language-csharp">int num = 0;
object numlock = new object();
Task.Run(
    () =&gt;
    {
        for (int i = 0; i &lt; 1000; i++)
        {
            lock (numlock)
                num++;
        }
        lock (numlock)
            Console.WriteLine(&quot;Thread 1 : &quot; + num);
    }
);
Task.Run(
    () =&gt;
    {
        for (int i = 0; i &lt; 1000; i++)
        {
            lock (numlock)
                num++;
        }
        lock (numlock)
            Console.WriteLine(&quot;Thread 2 : &quot; + num);
    }
);
</code></pre>
<p>下面这段代码展示了锁是如何阻塞线程的：</p>
<pre><code class="language-csharp">object tasklock = new object();
Task.Run(() =&gt;
    {
        lock (tasklock)
            for (int i = 0; i &lt; 5; i++)
            {
                Thread.Sleep(200);
                Console.WriteLine(&quot;Thread 1&quot;);
            }
    }
);
Task.Run(() =&gt;
    {
        lock (tasklock)
            for (int i = 0; i &lt; 5; i++)
            {
                Thread.Sleep(200);
                Console.WriteLine(&quot;Thread 2&quot;);
            }
    }
);
</code></pre>
<p>除了使用 lock 关键字，还可以使用 Moniter 来锁定和释放对象。</p>
<pre><code class="language-csharp">Monitor.Enter(objlock);
Monitor.Exit(objlock);
</code></pre>
<p>注意：</p>
<ul>
<li>应避免锁定 public 对象，否则实例将超出代码的控制范围。</li>
<li>锁定对象应当为 readonly 以免在锁定的过程中发生改变</li>
<li>不能锁定值类型</li>
</ul>
<pre><code class="language-csharp">lock(9) // 错误，不能锁定值类型
lock(this) // 错误，违反了不能锁定 public 对象的规范
lock(&quot;Hello World&quot;) // 错误，相同字符串同一程序中只有一个实例对象，相当于锁定 public 对象。
</code></pre>
<p>下面是正确示例</p>
<pre><code class="language-csharp">private static readonly object objlock = new object();
lock(objlock)
  ...
</code></pre>
<h3><a class="header" href="#读写锁" id="读写锁">读写锁</a></h3>
<p>允许多个线程同时获取读锁，但同一时间只允许一个线程获得写锁</p>
<p>当某个线程进入读取模式时，此时其他线程依然能进入读取模式，假设此时一个线程要进入写入模式，那么他不得不被阻塞。</p>
<p>如果某个线程进入了写入模式，那么其他线程无论是要写入还是读取，都是会被阻塞的。</p>
<pre><code class="language-csharp">ReaderWriterLockSlim rw = new ReaderWriterLockSlim();
int num = 5;
for (int i = 0; i &lt; 5; i++)
{
    int tmp = i;
    Task.Run(() =&gt;
    {
        rw.EnterReadLock();
        for (int j = 0; j &lt; 5; j++)
        {
            
            Thread.Sleep(200);
            Console.WriteLine(&quot;Thread &quot; + tmp + &quot; is reading&quot;);
        }
        rw.ExitReadLock();
    });
}
</code></pre>
<p>上面的代码展示了多个线程可以同时获取读锁。</p>
<pre><code class="language-csharp">ReaderWriterLockSlim rw = new ReaderWriterLockSlim();
int num = 5;
for (int i = 0; i &lt; 5; i++)
{
    int tmp = i;
    Task.Run(() =&gt;
    {
        for (int j = 0; j &lt; 5; j++)
        {
            rw.EnterReadLock();
            Thread.Sleep(200);
            Console.WriteLine(&quot;Thread &quot; + tmp + &quot; is reading&quot;);
            rw.ExitReadLock();
        }
    });
}
Thread.Sleep(400);
Task.Run(() =&gt;
{
    rw.EnterWriteLock();
    for (int j = 0; j &lt; 5; j++)
    {
        Thread.Sleep(200);
        Console.WriteLine(&quot;Thread is writing&quot;);
    }
    rw.ExitWriteLock();
});
</code></pre>
<p>上面的代码展示了当一个线程获取写锁的时候其他线程都被阻塞。</p>
<h3><a class="header" href="#死锁的产生" id="死锁的产生">死锁的产生</a></h3>
<p>考虑下面的程序运行过程：</p>
<p>Thread1 : lock 1 -&gt; attempt to lock 2</p>
<p>Thread2 : lock 2 -&gt; attempt to lock 1</p>
<p>这是一个最简单的死锁例子。两个线程都无法继续运行下去，程序产生了死锁。</p>
<pre><code class="language-csharp">object lock1 = new object();
object lock2 = new object();
Task.Run(() =&gt;
{
    lock (lock1)
    {
        Console.WriteLine(&quot;Thread 1 has lock 1&quot;);
        Thread.Sleep(1);
        Console.WriteLine(&quot;Thread 1 attempt to lock 2&quot;);
        lock (lock2)
        {
            Console.WriteLine(&quot;Thread 1 has lock 2&quot;);
        }
    }
});
Task.Run(() =&gt;
{
    lock (lock2)
    {
        Console.WriteLine(&quot;Thread 2 has lock 2&quot;);
        Thread.Sleep(1);
        Console.WriteLine(&quot;Thread 2 attempt to lock 1&quot;);
        lock (lock1)
        {
            Console.WriteLine(&quot;Thread 2 has lock 1&quot;);
        }
    }
});
</code></pre>
<h3><a class="header" href="#哲学家就餐问题" id="哲学家就餐问题">哲学家就餐问题</a></h3>
<p>有五个哲学家，他们的生活方式是交替地进行思考和进餐。他们共用一张圆桌，分别坐在五张椅子上。</p>
<p>在圆桌上有五个碗和五支筷子，平时哲学家进行思考，饥饿时便试图取用其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐。进餐完毕，放下筷子又继续思考。</p>
<p>死锁的产生：五位哲学家同时饥饿而各自拿起了左边的筷子，当他们试图去拿起右边的筷子时，都将因无筷子而无限期地等待下去。</p>
<h3><a class="header" href="#死锁产生的条件" id="死锁产生的条件">死锁产生的条件</a></h3>
<ol>
<li>互斥条件。即某个资源在一段时间内只能由一个进程占有</li>
<li>不可抢占条件。进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源</li>
<li>占有且申请条件。进程至少已经占有一个资源，但又申请新的资源</li>
<li>循环等待条件。存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......</li>
</ol>
<h3><a class="header" href="#死锁的解决" id="死锁的解决">死锁的解决</a></h3>
<ol>
<li>打破互斥条件，允许进程同时访问某些资源（废话）</li>
<li>打破不可抢占条件，即允许进程强行从占有者那里夺取某些资源（也是废话）</li>
<li>打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源（很难满足条件）</li>
<li>资源编号，线程在申请资源时，必须按顺序申请（实现简单，常用）</li>
<li>银行家算法（有一定的限制条件）</li>
</ol>
<p>资源编号策略：</p>
<ul>
<li>1 号哲学家拿起 1 号筷子</li>
<li>2 号哲学家拿起 2 号筷子</li>
<li>3 号哲学家拿起 3 号筷子</li>
<li>4 号哲学家拿起 4 号筷子</li>
<li>5 号哲学家拿起 ? 号筷子</li>
</ul>
<p>“避免死锁的最好办法，就是不要用锁。” 著名哲学家沃尔兹基说。</p>
<hr />
<h2><a class="header" href="#五原子操作" id="五原子操作">五、原子操作</a></h2>
<p>就如其字面意思，原子操作就是计算机中不可再分割的操作。</p>
<p>C# 提供了一个原子操作库 Interlocked ，可以使用 Interlocked 把常见的操作转化为原子操作。</p>
<p>常见的操作有 i++ （自增操作），如果使用 lock 则系统开销过大，不值得使用，可以使用原子操作进行改写。</p>
<pre><code class="language-csharp">int num = 0;
Task.Run(
    () =&gt;
    {
        for (int i = 0; i &lt; 1000; i++)
        {
            Interlocked.Increment(ref num);
        }
        Console.WriteLine(&quot;Thread 1 : &quot; + num);
    }
);
Task.Run(
    () =&gt;
    {
        for (int i = 0; i &lt; 1000; i++)
        {
            Interlocked.Increment(ref num);
        }
        Console.WriteLine(&quot;Thread 2 : &quot; + num);
    }
);
</code></pre>
<p>除了 Increment 之外，还有许多其他原子操作，比如：</p>
<pre><code class="language-csharp">Add(ref T a, T b); // a = a + b
Exchange(ref T a, T b); // a = b
CompareExchange(ref T a, T b, int c); // if(b == c) a = b;
Decrement(ref T a); // a--
</code></pre>
<hr />
<h2><a class="header" href="#六c-并发集合" id="六c-并发集合">六、C# 并发集合</a></h2>
<p>C# 默认的集合并不是线程安全的，当多个线程同时对一个集合作修改时可能会发生异常：</p>
<pre><code class="language-csharp">List&lt;int&gt; l = new List&lt;int&gt;();
Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10000; i++)
    {
        l.Add(i);
    }
    Thread.Sleep(10);
    Console.WriteLine(l.Count);
});
Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10000; i++)
    {
        l.Add(i);
    }
    Thread.Sleep(10);
    Console.WriteLine(l.Count);
});
</code></pre>
<p>C# 提供了多个线程安全集合类，这些线程安全集合都是无锁的，能够支持高效的多线程操作</p>
<p>下面以 ConcurrentQueue&lt; T &gt; 为例展示一下线程安全集合类的用法：</p>
<pre><code class="language-csharp">ConcurrentQueue&lt;int&gt; q = new ConcurrentQueue&lt;int&gt;(); // 新建一个线程安全队列。
q.Enqueue(9); // 数字 9 入队
q.TryDequeue(out int temp); // 从队列头取出一个数
Console.WriteLine(temp);
</code></pre>
<p>注意，Concurrent 集合通常都有 Try 方法，凡是 Try 方法都不一定能执行成功，并且都会返回一个布尔值，用来显示 Try 方法是否执行成功。</p>
<p>Concurrent 命名空间下没有 HashSet&lt; T &gt; 的对应线程安全集合，但可以用 ConcurrentDictionry&lt; T, byte &gt; 来代替。</p>
<p>除了 Concurrent 命名空间下的集合，C# 还提供了 BlockingCollection 阻塞集合。这个集合的特点是当集合为空时，想要从集合里取出元素会被阻塞</p>
<pre><code class="language-csharp">BlockingCollection&lt;int&gt; b = new BlockingCollection&lt;int&gt;();
Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10; i++)
    {
        Thread.Sleep(300);
        b.Add(i);
        Console.WriteLine(&quot;Add &quot; + i);
    }
});
Task.Run(() =&gt;
{
    for (int i = 0; i &lt; 10; i++)
    {
        Console.WriteLine(&quot;Take &quot; + b.Take());
    }
});
</code></pre>
<p>上面这段代码展示了 BlockingCollection 是如何把线程阻塞的。</p>
<p>利用 BlockingCollection 可以实现事件队列，强制把所有事件放在同一线程里执行。</p>
<pre><code class="language-csharp">BlockingCollection&lt;Action&gt; EventQueue = new BlockingCollection&lt;Action&gt;();
new Thread(() =&gt;
{
    while (true)
        EventQueue.Take()();
}).Start();
</code></pre>
<p>只需要很少的代码就可以实现事件队列的编写。</p>
<p>我们可以用如下代码测试事件队列：</p>
<pre><code class="language-csharp">for (int i = 0; i &lt; 10; i++)
{
    Thread.Sleep(300);
    Task.Run(() =&gt;
    {
        EventQueue.Add(() =&gt;
        {
            Console.WriteLine(DateTime.Now);
        });
    });
}
</code></pre>
<hr />
<h2><a class="header" href="#七c定时器" id="七c定时器">七、C#定时器</a></h2>
<p>C# 里提供了几种定时器的实现方法。</p>
<h3><a class="header" href="#systemthreadingtimer" id="systemthreadingtimer">System.Threading.Timer</a></h3>
<p>下面的代码展示了如何新建一个定时器</p>
<pre><code class="language-csharp">System.Threading.Timer timer = new Timer(
    (o) =&gt;
    {
        Console.WriteLine(&quot;Timer !&quot;);
    }, null, 1000, 200);
</code></pre>
<p>Timer() 的构造方法第一个参数为定时执行的回调函数，第二个参数为传递给回调的参数，第三个参数为 duetime ，即在开始计时前等待多长时间，第四个参数为 period ，即定时器周期。</p>
<p>也可以采用如下代码开始一个定时器：</p>
<pre><code class="language-csharp">System.Threading.Timer timer = new Timer(
    (o) =&gt;
    {
        Console.WriteLine(&quot;Timer !&quot;);
    });
timer.Change(1000, 200);
</code></pre>
<p>上面的定时器在构造时并没有开始运行，在调用 Change() 方法后才开始运行。</p>
<p>System.Threading.Timer 在运行过程中随时可以调用 Change() 方法改变定时器的周期。</p>
<h3><a class="header" href="#systemtimerstimer" id="systemtimerstimer">System.Timers.Timer</a></h3>
<p>System.Timers.Timer 是比 System.Threading.Timer 更加灵活的一种定时器。</p>
<p>下面的代码展示了如何使用 System.Timers.Timer</p>
<pre><code class="language-csharp">System.Timers.Timer timer = new System.Timers.Timer();
timer.Elapsed += (o, e) =&gt;
{
    Console.WriteLine(&quot;Timer !&quot;);
};
timer.Interval = 300;
timer.Enabled = true;
</code></pre>
<p>timer.Elapsed 是一个 event ，每个周期都会被调用。</p>
<p>注意： System.Timers.Timer 比 System.Threading.Timer 更加灵活的地方就在于 Elapsed ，你可以在不重新 new 定时器的情况下改变定时器的回调函数。</p>
<pre><code class="language-csharp">public static void CallBack(Object o, System.Timers.ElapsedEventArgs e)
{
    Console.WriteLine(&quot;Timer !&quot;);
}

System.Timers.Timer timer = new System.Timers.Timer();
timer.Elapsed += CallBack;
timer.Interval = 300;
timer.Enabled = true;
Thread.Sleep(1200);
timer.Elapsed -= CallBack; // 这里把 CallBack 函数剥离 Elapsed
</code></pre>
<p>System.Timers.Timer 的一些属性：</p>
<pre><code class="language-csharp">bool Enabled; // 定时器是否正在运行
bool AutoReset; // 定时器是否周期执行，若为false，则表明定时器只执行一次。
int Interval; // 定时器执行的周期
</code></pre>
<hr />
<h2><a class="header" href="#八c-线程池" id="八c-线程池">八、C# 线程池</a></h2>
<p>线程池的作用是避免重复创建和销毁线程。</p>
<p>程序里常常会创建大量线程，但这些线程只使用了一小段时间就被挂起或进入休眠，一直等到程序结束都不会再使用。</p>
<p>C# 提供了线程池用于线程复用，当一个异步方法想要调用线程来运行，可以先到线程池里看看有没有空闲线程</p>
<p>如果有空闲线程则调用空闲线程完成任务。</p>
<pre><code class="language-csharp">ThreadPool.QueueUserWorkItem(
    (o) =&gt;
    {
        for (int i = 0; i &lt; 5; i++)
        {
            Thread.Sleep(300);
            Console.WriteLine(&quot;Thread Pool !&quot;);
        }
    }
);
</code></pre>
<p>调用线程池非常简单，只要像上面这段代码一样把一个 Callback 塞进线程就行。</p>
<p>线程池在创建之初会有一个最小线程数，这与计算机的 CPU 核心数有关，可以用 ThreadPool.GetMinThreads() 方法获取。</p>
<pre><code class="language-csharp">ThreadPool.GetMinThreads(out int workerThreads, out int IOThreads);
Console.WriteLine(workerThreads + &quot;  &quot; + IOThreads);
</code></pre>
<p>需要注意的是，Task 和 Timer 也是默认调用线程池里的线程来完成工作的。</p>
<p>如果线程池中的线程被用完了怎么办呢？这个时候系统会停顿 1 秒钟，观察线程池中其他线程是否执行完毕，如果有线程执行完毕的话则调用这个线程，如果没有的话则对线程池进行扩容，增加一个线程。</p>
<pre><code class="language-csharp">for (int i = 0; i &lt; 12; i++)
{
    int tmp = i;
    Task.Run(() =&gt;
    {
        Console.WriteLine(&quot;Thread &quot; + tmp);
        Console.ReadKey();
    });
}
</code></pre>
<p>上面这段代码展示了线程池是如何进行扩容的。</p>
<p>我们可以用 SetMinThreads() 方法设置线程池的最小线程数</p>
<pre><code class="language-csharp">ThreadPool.SetMinThreads(16, 16);
</code></pre>
<p>设置了最小线程数后再执行上面的代码则不会出现新的任务要等待 1 秒的情况</p>
<p>我们也可以用 SetMaxThreads() 方法设置线程池的最小线程数</p>
<pre><code class="language-csharp">ThreadPool.SetMaxThreads(8, 8);
</code></pre>
<p>像这样设置了线程池的最大线程数后，上面的代码中 Thread 8 ~ 11 则永远不会被执行，因为 Thread 8 ~ 11 要等到线程池有空闲时才能执行。</p>
<p>线程池的其他方法：</p>
<pre><code class="language-csharp">ThreadPool.GetAvailableThreads(out int workerThreads, out int completionPortThreads); // 获取线程池中的空闲线程。
ThreadPool.ThreadCount; // 获取线程池中的线程数目
</code></pre>
<h1><a class="header" href="#unity3d基础" id="unity3d基础">Unity3D基础</a></h1>
<h4><a class="header" href="#unity简介" id="unity简介">Unity简介</a></h4>
<p>Unity是一款由Unity Technoligies开发的跨平台2D/3D游戏引擎，并可以发布到Windows, MacOS, Linux, iOS等诸多平台。</p>
<p>Unity官网：https://unity.com/</p>
<p>Unity官方学习资源：https://learn.unity.com/</p>
<p>Unity官方文档：https://docs.unity3d.com/Manual/index.html</p>
<p>Google/Unity Forums</p>
<h4><a class="header" href="#unity开发环境" id="unity开发环境">Unity开发环境</a></h4>
<p>Unity工程及Unity Editor版本管理：Unity Hub</p>
<p>图形化编辑界面：Unity Editor</p>
<p>下载地址：https://unity3d.com/get-unity/download</p>
<p>需要注册Unity账号。非盈利的个人开发者免费使用。</p>
<p>代码编辑器：Visual Studio（安装时选择&quot;使用Unity的游戏开发&quot;），VS Code（在Unity Editor中修改默认代码编辑器），其他。</p>
<h4><a class="header" href="#unity基本知识" id="unity基本知识">Unity基本知识</a></h4>
<h6><a class="header" href="#scene场景" id="scene场景">Scene（场景）</a></h6>
<p>Scene包含了若干GameObject，一个游戏可以包含多个场景，不同的场景之间是独立的，并且可以通过脚本切换场景。</p>
<h6><a class="header" href="#gameobject游戏对象" id="gameobject游戏对象">GameObject（游戏对象）</a></h6>
<p>一个GameObject就是场景中的一个对象，比如一个球，一个人；它可以独立地活动。GameObject之间存在Parent和Children的关系，即一个对象可以从属于另一个对象，成为其子对象。</p>
<p>请注意，GameObject之间的父子关系并非继承关系，而只是一种从属关系。</p>
<h6><a class="header" href="#component组件" id="component组件">Component（组件）</a></h6>
<p>一个GameObject可以拥有若干个Component，两者之间仍是一种从属关系。每个Component可以独立地实现GameObject需求的某些功能。常用的如Rigid（刚体），Animator（动画）等。</p>
<h6><a class="header" href="#prefab预设" id="prefab预设">Prefab（预设）</a></h6>
<p>Prefab与GameObject之间的关系类似于类和对象的关系。即后者是前者的实例。Prefab的使用能够减少不必要的重复工作。当Prefab被修改时，它的所有GameObject实例也会被修改。</p>
<h6><a class="header" href="#script脚本" id="script脚本">Script（脚本）</a></h6>
<p>通过编写代码，并将Script添加为某个GameObject的Component，当该GameObject被实例化并且处于活动状态，且该Component也处于活动状态时，它便可以控制GameObject的行为。</p>
<p>Unity脚本是基于Mono的，所有需要使用Unity引擎的脚本，都应该继承自MonoBehaviour类。换句话说，只有那些完全不依赖于Unity引擎进行初始化和更新，也不调用Unity的API的脚本，比如单纯进行数学计算的类，是不需要继承MonoBehaviour的。</p>
<h6><a class="header" href="#assets资源" id="assets资源">Assets（资源）</a></h6>
<p>你的所有Prefab, Script以及Material等资源都在Assets中进行管理。对于规模较大的工程，总应该建立规范的目录结构。</p>
<h6><a class="header" href="#所以unity是如何工作的" id="所以unity是如何工作的">所以，Unity是如何工作的？</a></h6>
<p>首先要加载一个场景。当场景被加载时，场景中的所有GameObject都会被加载。当GameObject加载时，其所有Component也随之实例化。当某个Script实例化时，其Awake()方法和Start()方法被先后调用（细节这里不说），当所有Start()方法都被调用完毕后，游戏会进入第一帧，每隔一段时间就会Update一次。</p>
<h4><a class="header" href="#unity开发实例" id="unity开发实例">Unity开发实例</a></h4>
<p>我们希望实现如下一个简单的游戏：键盘操纵角色在地图中移动，地图中会刷新得分点，当角色接触到得分点时就可以得分。游戏界面中应显示当前的时间，分数，并有重新开始，退出等按钮。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
